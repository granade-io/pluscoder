# Project Overview: AI-Driven Software Development Workflow

An AI-powered system that automates the entire software development lifecycle using LLM agents, from vision to production.

## Vision
To create an automated workflow entirely managed by LLM agents, capable of developing and maintaining complex software systems from vision to production.

## System Description
This project aims to develop a system that uses a composition of LLM agents, leveraging Langchain and LangGraph, to automate the entire software development lifecycle. The workflow encompasses various stages including vision creation, roadmap planning, development, quality assurance, and production deployment.

## Key Features

1. Multi-agent system with orchestration capabilities
   - Includes specialized agents (Domain Stakeholder, Domain Expert, Planning, Developer)
   - Orchestrator Agent manages workflow between agents
   - Support for custom agents with specialized roles and capabilities

2. Automated repository initialization and documentation
   - Automatically generates `PROJECT_OVERVIEW.md` and `CODING_GUIDELINES.md`
   - Detects and configures test and lint commands
   - Creates `.env` file with appropriate configurations

3. Task-based agent orchestration
   - Breaks down user requirements into manageable tasks
   - Executes tasks using appropriate agents

4. Agent chat loop and orchestration
   - Allows direct interaction with individual agents
   - Supports complex multi-agent workflows with max interactions to avoid infinite loops.

5. User approvals for key points in the workflow
   - Task list approval before execution
   - Agent selection at the start of the application

6. Automated file editing by agents
   - Agents can read and update project files based on their specialized knowledge

7. Auto-commit feature using Git event handler
   - Automatically creates Git commits for file changes made by agents
   - Enhances traceability and allows for easy review or reversion of modifications

8. Cost and token tracking for LLM interactions
   - Tracks token usage and calculates real-time cost information
   - Supports various LLM models with different pricing structures

9. Flexible configuration system
   - Configurable through command-line arguments, environment variables, and default values
   - Enhances project flexibility and ease of use

10. Support for multiple LLM models
   - Integration with LLMLite, OpenAI, and AWS Bedrock
   - Allows for easy switching between different LLM providers

11. Enhanced user interaction
    - Command-line interface with rich console output
    - Auto-completion for files and commands in user input
    - Slash commands for quick actions

12. Task execution progress display
    - Real-time updates on task status and agent activities

13. LLM input/output logging to file
    - Captures all interactions with LLM models for analysis and debugging

14. Command execution feature
    - Allows agents to execute system commands
    - Enhances agents' ability to interact with the development environment
    - Supports project setup, dependency management, and other development tasks

15. Repomap feature
    - Generates a structured overview of the project's codebase
    - Configurable include and exclude patterns for file selection
    - Adjustable detail level for code analysis
    - Enhances agents' understanding of the project structure and contents

## Technology Stack
- Primary Language: Python
- Key Libraries: Langchain, LangGraph
- LLM Integration: LLMLite, OpenAI, AWS Bedrock
- Additional Libraries: asyncio, dotenv, rich (for console output), prompt_toolkit (for advanced input features), argparse (for command-line argument parsing)

## Configuration and Startup
The project includes a flexible configuration system that allows setting various parameters:
- Through command-line arguments when running the application
- Via environment variables
- Using default values defined in the code
- Using a .pluscoder-config.yml file for persistent configuration

## Development Workflow
1. User selects an agent or starts with the Orchestrator.
2. If using the Orchestrator:
   a. User provides requirements.
   b. Orchestrator breaks down requirements into tasks.
   c. User approves the task list.
   d. Tasks are executed by appropriate agents.
   e. Progress is displayed in real-time.
   f. User can provide new requirements or end the session.
3. If using other agents:
   a. User can directly chat with the chosen agent.
   b. Agents can read and update files as needed.

## User Interaction
- Command-line interface using `rich` library for enhanced console output
- Input Handling: Uses `prompt_toolkit` for advanced input features, including multi-line input, file and command auto-completion
- Agent Selection: Users can choose which agent to interact with at the start of the application
- Task Approval: Users must approve the task list generated by the Orchestrator before execution
- Slash Commands: Quick actions for common operations
- Real-time progress display of task execution

## Version Control Integration
- Git Event Handler: Implements automatic commits when files are edited by agents
- This feature ensures that all changes made during the development process are tracked and versioned
- Enhances traceability and allows for easy rollback if needed
- Users can view diffs of AI-generated changes and manage the development process more effectively

## Challenges and Future Directions
- Optimizing task division and agent interactions
- Enhancing agents' understanding of the project state and vision
- Improving inter-agent communication by summarizing or limiting preserved messages
- Exploring solutions for better context retrieval (e.g., GraphRAG, project file tree summaries)
- Refining the output filtering system to present clear, concise information to users

## Next Steps

For detailed information on the project's next steps and prioritized features, please refer to the [ROADMAP.md](ROADMAP.md) file.

## Technical Considerations
- The project is in active development, with ongoing refinements to core functionalities
- Asynchronous operations are used throughout the system for improved performance
- The system is designed to be flexible and can integrate with different LLM providers
- Future updates may include more sophisticated state management for complex, multi-step processes

## Repository Structure
The project follows a well-organized structure:

1. Root Directory:
   - `.env.example`: Example environment variables file (not tracked in version control)
   - `PROJECT_OVERVIEW.md`: This file, containing the project overview
   - `CODING_GUIDELINES.md`: Guidelines for code development
   - `README.md`: Project readme file
   - `ROADMAP.md`: Project roadmap
   - `requirements.txt`: Project dependencies
   - `CHANGELOG.md`: Tracks version changes and updates to the project

2. Core Functionality:
   - `main.py`: The entry point of the application, executes the workflow with an state
   - `workflow.py`: Entire agents workflow
   - `agents/`: Directory containing agent-related files
     - `base.py`: Contains the base Agent class and core agent functionality
     - `core.py`: Defines specific agent types
     - `orchestrator.py`: Implements the Orchestrator Agent
     - `prompts.py`: Contains agent prompts
     - `event/`: Subdirectory for event-related functionality
       - `base.py`: Defines AgentEvent enum, AgentEventBaseHandler, and EventEmitter classes
       - `config.py`: Configures event emitter and handlers
       - `event_handler/`: Subdirectory for specific event handlers
         - `base.py`: Base event handler class
         - `console_event_handler.py`: Implements ConsoleAgentEventHandler for progress tracking
         - `git_event_handler.py`: Implements GitAgentEventHandler for auto-commit functionality
   - `tools.py`: Implements various tools used by the agents
   - `fs.py`: Handles file system operations
   - `io_utils.py`: Manages enhanced input/output operations
   - `logs.py`: Handles logging functionality
   - `exceptions.py`: Defines custom exceptions for the project
   - `message_utils.py`: Utility functions for message handling
   - `model.py`: Defines data models
   - `repo.py`: Handles repository-related operations
   - `type.py`: Defines custom types

3. Testing:
   - `tests/`: Directory containing test files
     - `conftest.py`: Configuration for pytest
     - `test_agents/`: Tests for agent functionality
     - `test_fs.py`: Tests for file system operations
     - `test_tools.py`: Tests for tools

4. CI/CD:
   - `.gitlab-ci.yml`: GitLab CI/CD configuration file
   - `Dockerfile`: Defines the Docker image for the project

This structure separates concerns effectively, with clear distinctions between agent definitions, utility functions, and testing. The use of a dedicated `agents` directory allows for easy addition of new agent types as the project evolves.

## Note
This project is in active development, and many aspects are continuously being refined and improved. The information in this overview is subject to change as the project evolves.
