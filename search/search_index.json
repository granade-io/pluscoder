{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to PlusCoder","text":"<p> Software AI Agents working for you Coding Repository maintenance Brainstorming Planning and more.. </p> <p>     PlusCoder is a Python agent framework designed to make it less painful to     build production grade applications with Generative AI. </p>"},{"location":"#overview","title":"Overview","text":"<p>Welcome to the PlusCoder documentation. This section provides comprehensive guides for understanding and using the PlusCoder AI-Driven Software Development Workflow.</p>"},{"location":"#sections","title":"Sections","text":"<ul> <li>Installation and Setup</li> <li>Quick Start</li> </ul>"},{"location":"api/agents/","title":"Agents API Reference","text":""},{"location":"api/agents/#base-agent","title":"Base Agent","text":""},{"location":"api/agents/#pluscoder.agents.base","title":"pluscoder.agents.base","text":""},{"location":"api/agents/#pluscoder.agents.base.Agent","title":"Agent","text":"Source code in <code>pluscoder/agents/base.py</code> <pre><code>class Agent:\n    state_schema = OrchestrationState\n\n    def __init__(\n        self, agent_config: AgentConfig, stream_parser: XMLStreamParser, extraction_tools: list[Callable] = []\n    ):\n        self.id = agent_config.id\n        self.name = agent_config.name\n        self.system_message = agent_config.prompt\n        self.tools = [getattr(tools, tool, None) for tool in agent_config.tools if getattr(tools, tool, None)]\n        self.extraction_tools = extraction_tools\n        self.default_context_files = agent_config.default_context_files\n        self.graph = self.get_graph()\n        self.max_deflections = 3\n        self.current_deflection = 0\n        self.repo = Repository(io=io)\n        self.state = None\n        self.disable_reminder = False\n        self.read_only = agent_config.read_only\n        self.description = agent_config.description\n        self.reminder = agent_config.reminder\n        self.repository_interaction = agent_config.repository_interaction\n        self.stream_parser = stream_parser\n        self.updated_files = set()\n\n    def get_context_files(self, state):\n        state_files = state.get(\"context_files\") or []\n        files = [*self.default_context_files, *state_files]\n\n        # remove duplicates\n        return list(set(files))\n\n    def get_context_files_panel(self, files):\n        if files:\n            files_context = \" \".join(files[0:5]) + (f\" (+{len(files) - 5} files)\" if len(files) &gt; 5 else \"\")\n        else:\n            files_context = \"&lt;No files available&gt;\"\n        return f\"&gt; Files context: {files_context}\"\n\n    def get_files_not_in_context(self, state):\n        context_files = set(self.get_context_files(state))\n        all_tracked_files = set(self.repo.get_tracked_files())\n        return sorted(all_tracked_files - context_files)\n\n    def get_files_context_prompt(self, state):\n        files_not_in_context = self.get_files_not_in_context(state)\n\n        prompt = f\"\"\"\nHere is the latest content of those repository files that you already have access to read/edit: \\n\\n{{files_content}}\n\nHere are all repository files you don't have access yet: \\n\\n{files_not_in_context}\n\"\"\"\n\n        if config.use_repomap:\n            prompt += \"\\n\\nHere is the repository map summary so you can handle request better:\\n\\n{repomap}\\n\"\n\n        return prompt\n\n    def get_repomap(self):\n        return self.repo.generate_repomap()\n\n    def get_system_message(self, state: OrchestrationState):\n        return build_system_prompt(\n            self.system_message,\n            can_read_files=self.repository_interaction,\n            can_edit_files=not self.read_only and not config.read_only and self.repository_interaction,\n        )\n\n    def get_reminder_prefill(self, state: OrchestrationState) -&gt; str:\n        prompt = REMINDER_PREFILL_PROMPT\n        if not config.read_only and not self.read_only and self.repository_interaction:\n            prompt += REMINDER_PREFILL_FILE_OPERATIONS_PROMPT\n        if self.reminder:\n            prompt += self.reminder\n        return prompt\n\n    def get_prompt_template_messages(self, state: OrchestrationState):\n        templates_messages = [(\"system\", self.get_system_message(state))]\n\n        if self.repository_interaction:\n            # Context files\n            templates_messages += [\n                (\"user\", self.get_files_context_prompt(state)),\n                AIMessage(content=\"ok\", name=self.id),\n            ]\n        return templates_messages + [\n            (\"placeholder\", \"{messages}\"),\n        ]\n\n    def build_assistant_prompt(self, state: OrchestrationState, deflection_messages: list):\n        # last_message = state[\"messages\"][-1]\n        # check if last message is from a tool\n        # if last_message.type == \"tool\":\n        #     user_message_list = []\n        #     place_holder_messages = state[\"messages\"]\n        # else:\n        #     user_message_list = [state[\"messages\"][-1]]\n        #     place_holder_messages = state[\"messages\"][:-1]\n\n        context_files = self.get_context_files(state)\n        files_content = get_formatted_files_content(context_files)\n\n        # reminders\n        reminder_messages = []\n        if not self.disable_reminder:\n            reminder_messages.append(HumanMessage(content=self.get_reminder_prefill(state), tags=[self.id]))\n\n        # Get stale content version of messages\n        all_messages = state[\"messages\"] + deflection_messages + reminder_messages\n        processed_messages = mask_stale_file_messages(all_messages)\n\n        # assistant_prompt\n        return RunnableMap(\n            {\n                \"messages\": lambda x: processed_messages,\n                \"files_content\": lambda x: files_content,\n                \"repomap\": lambda x: self.get_repomap() if config.use_repomap else \"\",\n            }\n        ) | ChatPromptTemplate.from_messages(self.get_prompt_template_messages(state))\n\n    def get_tool_choice(self, state: OrchestrationState) -&gt; str:\n        \"\"\"Chooses a the tool to use when calling the llm\"\"\"\n        return \"auto\"\n\n    def get_agent_model(self):\n        return get_llm()\n\n    def _stream_events(self, chain, state: OrchestrationState, deflection_messages: List[str]):\n        self.stream_parser.start_stream()\n        first = True\n        gathered = None\n        try:\n            for chunk in chain.stream(\n                {\n                    \"messages\": state[\"messages\"],\n                    \"deflection_messages\": deflection_messages,\n                },\n                {\"callbacks\": [file_callback]},\n            ):\n                if first:\n                    self.stream_parser.stream(chunk.content)\n                    gathered = chunk\n                    first = False\n                else:\n                    self.stream_parser.stream(chunk.content)\n                    gathered = gathered + chunk\n        finally:\n            try:\n                self.stream_parser.close_stream()\n            except Exception as e:\n                print(f\"Error in stream events: {e}\")\n\n        # coerce to message\n        return message_chunk_to_message(cast(BaseMessageChunk, convert_to_messages([gathered])[0]))  # type: ignore\n\n    def _invoke_llm_chain(self, state: OrchestrationState, deflection_messages: List[str] = []):\n        assistant_prompt = self.build_assistant_prompt(state, deflection_messages=deflection_messages)\n        llm = self.get_agent_model()\n        chain: Runnable = assistant_prompt | llm.bind_tools(\n            self.tools + self.extraction_tools, tool_choice=self.get_tool_choice(state)\n        )\n\n        if config.streaming:\n            return self._stream_events(chain, state, deflection_messages)\n\n        # response\n        return chain.invoke(\n            {\n                \"messages\": state[\"messages\"],\n                \"deflection_messages\": deflection_messages,\n            },\n            {\"callbacks\": [file_callback]},\n        )\n\n    def call_agent(self, state):\n        \"\"\"When entering this agent graph, this function is the first node to be called\"\"\"\n\n        self.get_context_files(state)\n        self.disable_reminder = False\n        # io.event(self.get_context_files_panel(context_files))\n\n        interaction_msgs = []\n        post_process_state = {}\n\n        with get_openai_callback() as cb:\n            backoff_time = 2  # Start with 3 seconds\n            while self.current_deflection &lt;= self.max_deflections:\n                try:\n                    llm_response = self._invoke_llm_chain(state, interaction_msgs)\n                    llm_response.tags = [self.id]\n\n                    interaction_msgs.append(llm_response)\n                    post_process_state = self.process_agent_response(state, llm_response)\n                    backoff_time = 2  # Reset backoff time on success\n                    break\n                except AgentException as e:\n                    # Disable sysetem reminders when solving specific errors\n                    self.disable_reminder = True\n\n                    io.log_to_debug_file(\"## AgentException Deflection\")\n                    io.log_to_debug_file(e.message, indent=4)\n\n                    # io.console.print(f\"Error: {e!s}\")\n                    io.console.print(\"::re-thinking due an issue:: \", style=\"bold dark_goldenrod\")\n                    if self.current_deflection &lt;= self.max_deflections:\n                        self.current_deflection += 1\n                        interaction_msgs.append(HumanMessage(content=f\"An error ocurred: {e!s}\", tags=[self.id]))\n                        sleep(backoff_time)\n                        backoff_time *= 2  # Exponential backoff\n                except Exception as e:\n                    # Handles unknown exceptions, maybe caused by llm api or wrong state\n                    io.console.print(f\"An error ocurred when calling model: {e!s}\", style=\"bold red\")\n                    error_traceback = traceback.format_exc()\n                    if config.debug:\n                        io.console.log(f\"Traceback:\\n{error_traceback}\", style=\"bold red\")\n                    io.log_to_debug_file(f\"\\n\\nTraceback:\\n{error_traceback}\", indent=4)\n                    io.log_to_debug_file(\"State:\")\n                    io.log_to_debug_file(message=str(state), indent=4)\n                    io.log_to_debug_file(\"Deflection messages:\")\n                    io.log_to_debug_file(message=str(interaction_msgs), indent=4)\n                    sleep(backoff_time)  # Wait a bit, some api calls need time to recover\n                    interaction_msgs.append(\n                        HumanMessage(content=\"An error occurred. Please try exactly the same again\", tags=[self.id])\n                    )\n                    if self.current_deflection &lt;= self.max_deflections:\n                        self.current_deflection += 1\n                        sleep(backoff_time)\n                        backoff_time *= 2  # Exponential backoff\n\n        # new_state\n        return {\n            \"messages\": interaction_msgs + post_process_state.get(\"messages\", []),\n            \"token_usage\": {\n                \"total_tokens\": cb.total_tokens,\n                \"prompt_tokens\": cb.prompt_tokens,\n                \"completion_tokens\": cb.completion_tokens,\n                \"total_cost\": cb.total_cost,\n            },\n        }\n\n    def agent_router(self, state: OrchestrationState) -&gt; Literal[\"tools\", \"__end__\"]:\n        \"\"\"Edge to chose next node after agent was executed\"\"\"\n        # Ends agent if max deflections reached\n        if self.current_deflection &gt; self.max_deflections:\n            io.console.log(\"Maximum deflections reached. Stopping.\", style=\"bold dark_goldenrod\")\n            return \"__end__\"\n\n        messages = state[\"messages\"]\n        last_message = messages[-1]\n\n        if last_message.tool_calls:\n            return \"tools\"\n\n        return \"__end__\"\n\n    def parse_tool_node(self, state: OrchestrationState):\n        messages = state[\"messages\"]\n\n        # Mark tool message for filtering\n        messages = tag_messages(messages, tags=[self.id], exclude_tagged=True)\n\n        last_message = filter_messages(messages, include_types=[\"ai\"])[-1]\n        # Last message that contains ToolMessage with executed tool data. We need to extract tool args from AIMessage at index -2\n        tool_data = {}\n\n        for tool_call in last_message.tool_calls:\n            # Extract data if extraction tool was used\n            if tool_call[\"name\"] in [tool.name for tool in self.extraction_tools]:\n                tool_data[tool_call[\"name\"]] = tool_call[\"args\"]\n\n        return {\n            **state,\n            \"tool_data\": tool_data,\n            # \"context_files\": state[\"context_files\"] + loaded_files,\n        }\n\n    def parse_tools_router(self, state: OrchestrationState) -&gt; Literal[\"__end__\", \"agent\"]:\n        \"\"\"Edge to decide where to go after all tools data was extracted\"\"\"\n\n        last_message = state[\"messages\"][-1]\n\n        # check if called tool were extraction tools\n        if last_message.type == \"tool\" and last_message.name in [tool.name for tool in self.extraction_tools]:\n            # Extractions tools dosn't need to go back to agent to review them.\n            return \"__end__\"\n\n        # If a normal tool was used, go back to agent to review its output and generate a new response.\n        return \"agent\"\n\n    def get_graph(self):\n        tool_node = ToolNode(self.tools + self.extraction_tools)\n\n        workflow = StateGraph(self.state_schema)\n\n        workflow.add_node(\"agent\", self.call_agent)\n        workflow.add_node(\"tools\", tool_node)\n        workflow.add_node(\"parse_tools\", self.parse_tool_node)\n\n        workflow.add_conditional_edges(\"agent\", self.agent_router)\n        workflow.add_edge(\"tools\", \"parse_tools\")\n        workflow.add_conditional_edges(\"parse_tools\", self.parse_tools_router)\n\n        workflow.set_entry_point(\"agent\")\n\n        return workflow.compile()\n\n    async def graph_node(self, state):\n        \"\"\"Node for handling interactions with the user and other nodes. Called every time a new message is received.\"\"\"\n\n        # Restart deflection counter\n        self.current_deflection = 0\n\n        # Resets updated files of this call\n        self.updated_files = set()\n\n        state_updates = self.graph.invoke(state, {\"callbacks\": [file_callback]})\n\n        io.console.print(\"\")\n        return {**state, **state_updates, \"messages\": state_updates[\"messages\"]}\n\n    def process_agent_response(self, state, response: AIMessage):\n        # Ignore process until all tools are executed\n        if response.tool_calls:\n            return {}\n\n        # Ignore process until all tools are executed\n        if response.tool_calls:\n            return {}\n\n        # Updated files of the call\n        call_updated_files = self.stream_parser.get_updated_files()\n        self.updated_files.update(call_updated_files)\n\n        error_messages = self.stream_parser.agent_errors\n\n        # check if last message has tool calls to ignore lint/test when files were edited during tool call\n\n        if error_messages:\n            updated_files_msg = (\n                f\"You successfully updated these files: {', '.join(call_updated_files)}, but there are some issues.\\n\"\n                if call_updated_files\n                else \"\"\n            )\n            raise AgentException(\n                \"Some errors occurred when executing your actions\"\n                + \"\\n\".join(error_messages)\n                + \"\\nPlease review all errors and solve the present issues if you can. Maybe you will need to read files again to understand what is missing or what happened.\"\n                + updated_files_msg\n            )\n\n        if call_updated_files:\n            # Run tests and linting if enabled\n            lint_error = self.repo.run_lint()\n            test_error = self.repo.run_test()\n\n            if lint_error or test_error:\n                error_message = \"Errors found:\\n\"\n                if lint_error:\n                    error_message += f\"Linting: {lint_error}\\n\"\n                if test_error:\n                    error_message += f\"Tests: {test_error}\\n\"\n                raise AgentException(error_message)\n\n        # Updated files during entire agent execution\n        file_editions_msgs = []\n        if self.updated_files:\n            if len(self.updated_files) &gt; 1:\n                io.event(f\"&gt; These files were successfully updated: {', '.join(self.updated_files)}\")\n            try:\n                if len(self.updated_files) &gt; 1:\n                    io.event(f\"&gt; These files were successfully updated: {', '.join(self.updated_files)}\")\n                # Try to get current event loop\n                loop = asyncio.get_running_loop()\n                # If exists, run in current loop\n                loop.create_task(event_emitter.emit(\"files_updated\", updated_files=self.updated_files))  # noqa: RUF006\n            except RuntimeError:\n                # If no loop exists, create new one\n                asyncio.run(event_emitter.emit(\"files_updated\", updated_files=self.updated_files))\n            finally:\n                file_editions_msgs = [build_file_editions_tool_message(list(self.updated_files), agent_id=self.id)]\n                self.updated_files = set()\n\n        # Add file editions tool message so agent can understand files was updated successfully\n        return {\"messages\": file_editions_msgs}\n</code></pre>"},{"location":"api/agents/#pluscoder.agents.base.Agent.agent_router","title":"agent_router","text":"<pre><code>agent_router(state: OrchestrationState) -&gt; Literal['tools', '__end__']\n</code></pre> <p>Edge to chose next node after agent was executed</p> Source code in <code>pluscoder/agents/base.py</code> <pre><code>def agent_router(self, state: OrchestrationState) -&gt; Literal[\"tools\", \"__end__\"]:\n    \"\"\"Edge to chose next node after agent was executed\"\"\"\n    # Ends agent if max deflections reached\n    if self.current_deflection &gt; self.max_deflections:\n        io.console.log(\"Maximum deflections reached. Stopping.\", style=\"bold dark_goldenrod\")\n        return \"__end__\"\n\n    messages = state[\"messages\"]\n    last_message = messages[-1]\n\n    if last_message.tool_calls:\n        return \"tools\"\n\n    return \"__end__\"\n</code></pre>"},{"location":"api/agents/#pluscoder.agents.base.Agent.call_agent","title":"call_agent","text":"<pre><code>call_agent(state)\n</code></pre> <p>When entering this agent graph, this function is the first node to be called</p> Source code in <code>pluscoder/agents/base.py</code> <pre><code>def call_agent(self, state):\n    \"\"\"When entering this agent graph, this function is the first node to be called\"\"\"\n\n    self.get_context_files(state)\n    self.disable_reminder = False\n    # io.event(self.get_context_files_panel(context_files))\n\n    interaction_msgs = []\n    post_process_state = {}\n\n    with get_openai_callback() as cb:\n        backoff_time = 2  # Start with 3 seconds\n        while self.current_deflection &lt;= self.max_deflections:\n            try:\n                llm_response = self._invoke_llm_chain(state, interaction_msgs)\n                llm_response.tags = [self.id]\n\n                interaction_msgs.append(llm_response)\n                post_process_state = self.process_agent_response(state, llm_response)\n                backoff_time = 2  # Reset backoff time on success\n                break\n            except AgentException as e:\n                # Disable sysetem reminders when solving specific errors\n                self.disable_reminder = True\n\n                io.log_to_debug_file(\"## AgentException Deflection\")\n                io.log_to_debug_file(e.message, indent=4)\n\n                # io.console.print(f\"Error: {e!s}\")\n                io.console.print(\"::re-thinking due an issue:: \", style=\"bold dark_goldenrod\")\n                if self.current_deflection &lt;= self.max_deflections:\n                    self.current_deflection += 1\n                    interaction_msgs.append(HumanMessage(content=f\"An error ocurred: {e!s}\", tags=[self.id]))\n                    sleep(backoff_time)\n                    backoff_time *= 2  # Exponential backoff\n            except Exception as e:\n                # Handles unknown exceptions, maybe caused by llm api or wrong state\n                io.console.print(f\"An error ocurred when calling model: {e!s}\", style=\"bold red\")\n                error_traceback = traceback.format_exc()\n                if config.debug:\n                    io.console.log(f\"Traceback:\\n{error_traceback}\", style=\"bold red\")\n                io.log_to_debug_file(f\"\\n\\nTraceback:\\n{error_traceback}\", indent=4)\n                io.log_to_debug_file(\"State:\")\n                io.log_to_debug_file(message=str(state), indent=4)\n                io.log_to_debug_file(\"Deflection messages:\")\n                io.log_to_debug_file(message=str(interaction_msgs), indent=4)\n                sleep(backoff_time)  # Wait a bit, some api calls need time to recover\n                interaction_msgs.append(\n                    HumanMessage(content=\"An error occurred. Please try exactly the same again\", tags=[self.id])\n                )\n                if self.current_deflection &lt;= self.max_deflections:\n                    self.current_deflection += 1\n                    sleep(backoff_time)\n                    backoff_time *= 2  # Exponential backoff\n\n    # new_state\n    return {\n        \"messages\": interaction_msgs + post_process_state.get(\"messages\", []),\n        \"token_usage\": {\n            \"total_tokens\": cb.total_tokens,\n            \"prompt_tokens\": cb.prompt_tokens,\n            \"completion_tokens\": cb.completion_tokens,\n            \"total_cost\": cb.total_cost,\n        },\n    }\n</code></pre>"},{"location":"api/agents/#pluscoder.agents.base.Agent.get_tool_choice","title":"get_tool_choice","text":"<pre><code>get_tool_choice(state: OrchestrationState) -&gt; str\n</code></pre> <p>Chooses a the tool to use when calling the llm</p> Source code in <code>pluscoder/agents/base.py</code> <pre><code>def get_tool_choice(self, state: OrchestrationState) -&gt; str:\n    \"\"\"Chooses a the tool to use when calling the llm\"\"\"\n    return \"auto\"\n</code></pre>"},{"location":"api/agents/#pluscoder.agents.base.Agent.graph_node","title":"graph_node  <code>async</code>","text":"<pre><code>graph_node(state)\n</code></pre> <p>Node for handling interactions with the user and other nodes. Called every time a new message is received.</p> Source code in <code>pluscoder/agents/base.py</code> <pre><code>async def graph_node(self, state):\n    \"\"\"Node for handling interactions with the user and other nodes. Called every time a new message is received.\"\"\"\n\n    # Restart deflection counter\n    self.current_deflection = 0\n\n    # Resets updated files of this call\n    self.updated_files = set()\n\n    state_updates = self.graph.invoke(state, {\"callbacks\": [file_callback]})\n\n    io.console.print(\"\")\n    return {**state, **state_updates, \"messages\": state_updates[\"messages\"]}\n</code></pre>"},{"location":"api/agents/#pluscoder.agents.base.Agent.parse_tools_router","title":"parse_tools_router","text":"<pre><code>parse_tools_router(state: OrchestrationState) -&gt; Literal['__end__', 'agent']\n</code></pre> <p>Edge to decide where to go after all tools data was extracted</p> Source code in <code>pluscoder/agents/base.py</code> <pre><code>def parse_tools_router(self, state: OrchestrationState) -&gt; Literal[\"__end__\", \"agent\"]:\n    \"\"\"Edge to decide where to go after all tools data was extracted\"\"\"\n\n    last_message = state[\"messages\"][-1]\n\n    # check if called tool were extraction tools\n    if last_message.type == \"tool\" and last_message.name in [tool.name for tool in self.extraction_tools]:\n        # Extractions tools dosn't need to go back to agent to review them.\n        return \"__end__\"\n\n    # If a normal tool was used, go back to agent to review its output and generate a new response.\n    return \"agent\"\n</code></pre>"},{"location":"api/agents/#core-agents","title":"Core Agents","text":""},{"location":"api/agents/#pluscoder.agents.core","title":"pluscoder.agents.core","text":""},{"location":"api/agents/#orchestrator-agent","title":"Orchestrator Agent","text":""},{"location":"api/agents/#pluscoder.agents.orchestrator","title":"pluscoder.agents.orchestrator","text":""},{"location":"api/agents/#pluscoder.agents.orchestrator.OrchestratorAgent","title":"OrchestratorAgent","text":"<p>               Bases: <code>Agent</code></p> Source code in <code>pluscoder/agents/orchestrator.py</code> <pre><code>class OrchestratorAgent(Agent):\n    id = \"orchestrator\"\n\n    specialization_prompt = \"\"\"\n*SPECIALIZATION INSTRUCTIONS*:\nYou are the Orchestrator Agent, your role is to understand user requirements to generate/plan a proper list of task to solve those requirements with the help of specialized Pluscoder AI Agents.\n\n&lt;specialization_context&gt;\n1. Other Pluscoder agents are mostly like you. Then know and have access to the same repository and can work over it, creating files, analyzing, summarizing, coding, document, etc\n2. They have the same limitations as you. They can't run bash commands for example.\n3. They can read files from urls or from user SO/repository\n4. They don't have memory, when delegating tasks they will only have access to the task list you provide to them.\n5. They can visually read images if these starts with img::&lt;image_path_or_utl&gt;, same as you can do, otherwise they will only see the path\n&lt;/specialization_context&gt;\n\n&lt;available_agents_to_delegate_tasks&gt;\n*Available Agents*:\n- Developer Agent: For writing code, documentation, tests, etc.\n&lt;/available_agents_to_delegate_tasks&gt;\n\n&lt;task_item_structure&gt;\n[] '&lt;task name&gt;'\n   'Objective': &lt;task objective&gt;\n   'Details': &lt;task details&gt; Details of the task to complete. Always include file paths to give more context, and functions/class/method names. Always include references to files edited by previous tasks to explain how tasks are related.\n   'Agent': &lt;agent name&gt; Agent who is responsible for this task.\n   'Restrictions': &lt;task restrictions&gt; Any limitations or constraints for the task.\n   'Outcome': &lt;expected outcome&gt; The expected result (file updates) of completing this task.\n&lt;/task_item_structure&gt;\n\n&lt;task_list_examples&gt;\n* All following tasks are examples, do not use them as a reference. Create your own list of tasks and follow the given instructions to complete them *\n    &lt;example requirement=\"add a cli option to display weather information\"&gt;\n        'General objective': Implement Weather Feature\n\n        [ ] 'Implement Weather Data Fetching and CLI Command'\n        'Objective': Add functionality to fetch current weather data from an API and create a CLI command\n        'Details': Create a new file `code/weather.py`. Implement a `WeatherService` class with a method `get_current_weather(city: str)` that fetches weather data for a given city using an external API (e.g., OpenWeatherMap). Use the `requests` library for HTTP calls. In the same file, implement a CLI command `weather` that uses this service. Update `code/commands.py` to include the new weather command in the command parser.\n        'Agent': Developer\n        'Restrictions': Use only the `requests` library for API calls. Ensure proper error handling for API requests.\n        'Outcome': New file `code/weather.py` with `WeatherService` class and CLI command implementation. Updated `code/commands.py` with new weather command added to the parser.\n\n        [ ] 'Create Unit Tests for Weather Feature'\n        'Objective': Implement unit tests for the new weather functionality\n        'Details': Create a new file `tests/test_weather.py`. Write unit tests to verify the correct functioning of the `WeatherService` class, its `get_current_weather()` method, and the CLI command. Include tests for successful API calls, error handling, and edge cases. Use mocking to avoid actual API calls during testing.\n        'Agent': Developer\n        'Restrictions': Use pytest for writing tests. Ensure all tests are independent and do not rely on external services.\n        'Outcome': New file `tests/test_weather.py` with comprehensive unit tests for the weather feature.\n\n        [ ] 'Update Project Documentation'\n        'Objective': Document the new weather feature in project files\n        'Details': Update `PROJECT_OVERVIEW.md` to include information about the new weather feature. Add a section in `README.md` explaining how to use the new weather command, including any required API keys or configuration, and provide an example of the output.\n        'Agent': Developer\n        'Restrictions': Ensure documentation is clear and concise. Include any setup steps required for the weather API.\n        'Outcome': Updated `PROJECT_OVERVIEW.md` and `README.md` files with new sections detailing the weather feature.\n    &lt;/example&gt;\n    &lt;example requirement=\"allow client to process csv data\"&gt;\n        'General objective': Implement Data Processing Feature\n\n        [ ] 'Implement CSV Data Processing and CLI Interface'\n        'Objective': Add functionality to process CSV files, calculate statistics, and create a CLI interface\n        'Details': Create a new file `code/data_processor.py`. Implement a `CSVProcessor` class with a method `calculate_stats(file_path: str)` that reads a CSV file, calculates basic statistics (mean, median, mode) for numeric columns, and returns the results. Use the `pandas` library for data processing. In the same file, implement a CLI command `process-csv` that uses this processor. Update `code/commands.py` to include the new CSV processing command in the command parser.\n        'Agent': Developer\n        'Restrictions': Use only the `pandas` library for CSV processing. Ensure proper error handling for file operations and data processing.\n        'Outcome': New file `code/data_processor.py` with `CSVProcessor` class and CLI command implementation. Updated `code/commands.py` with new CSV processing command added to the parser.\n\n        [ ] 'Create Unit Tests for CSV Processing'\n        'Objective': Implement unit tests for the new CSV processing functionality\n        'Details': Create a new file `tests/test_csv_processor.py`. Write unit tests to verify the correct functioning of the `CSVProcessor` class, its `calculate_stats()` method, and the CLI command. Include tests for various CSV formats, error handling, and edge cases. Create sample CSV files in a `tests/data/` directory to use in these tests.\n        'Agent': Developer\n        'Restrictions': Use pytest for writing tests. Ensure all tests are independent and use mock data.\n        'Outcome': New file `tests/test_csv_processor.py` with comprehensive unit tests for the CSV processing feature. New directory `tests/data/` with sample CSV files for testing.\n\n        [ ] 'Update Project Documentation for CSV Processing'\n        'Objective': Document the new CSV processing feature in project files\n        'Details': Update `PROJECT_OVERVIEW.md` to include information about the new CSV processing feature. Add a section in `README.md` explaining how to use the new CSV processing command, including expected CSV format, the statistics calculated, and provide an example command with sample output.\n        'Agent': Developer\n        'Restrictions': Ensure documentation is clear and concise. Include any dependencies required for the CSV processing feature.\n        'Outcome': Updated `PROJECT_OVERVIEW.md` and `README.md` files with new sections detailing the CSV processing feature.\n    &lt;/example&gt;\n    &lt;example requirement=\"generate an overview documentation of this backend and frontend project at PROJECT_OVERVIEW.md\"&gt;\n        Example 3: Project Analysis and Overview\n\n        [ ] 'Analyze Project Structure and Components'\n        'Objective': Examine and summarize the project's backend, frontend, and integration components\n        'Details': Analyze the following files:\n        - Backend: `src/server/app.js`, `src/server/models/index.js`, `src/server/controllers/index.js`\n        - Frontend: `src/client/App.js`, `src/client/components/index.js`, `src/client/pages/index.js`\n        - Integration: `src/server/config/database.js`, `src/server/routes/api.js`, `src/client/services/api.js`\n        Summarize the findings in a single file `temp_project_analysis.md`, organizing the information into sections for backend, frontend, and integration.\n        'Agent': Developer\n        'Restrictions': Focus on high-level architecture and key components. Do not include low-level implementation details.\n        'Outcome': New file `temp_project_analysis.md` with a comprehensive summary of the project's structure and components.\n\n        [ ] 'Generate Structured Project Overview'\n        'Objective': Create a comprehensive, structured overview of the project based on the analysis\n        'Details': Using the information from `temp_project_analysis.md`, create a new file `PROJECT_OVERVIEW.md` in the project root. Organize the information into sections such as \"Backend Architecture\", \"Frontend Structure\", \"Database Schema\", \"API Integration\", and \"Key Features\". Include relevant file paths, main components, and brief explanations of their purposes. Ensure the document provides a clear, high-level understanding of the project's structure and functionality.\n        'Agent': Developer\n        'Restrictions': The overview should be concise yet comprehensive. Use clear headings and subheadings for easy navigation.\n        'Outcome': New file `PROJECT_OVERVIEW.md` with a structured, comprehensive overview of the project. Deletion of the temporary `temp_project_analysis.md` file.\n    &lt;/example&gt;\n&lt;/task_list_examples&gt;\n\n&lt;main_specialization_responsibilities&gt;\n    Ask key questions about the requirement to understand the user vision and goals deeply, including technical aspects &amp; non-technical aspects.\n    Simple requirements requires less (or no) questions than complex ones. Choose key questions that will help you create a comprehensive list of tasks.\n\n    Do not propose a list of task until you understand the user requirements deeply through asking detailed questions. *Do not* ask more than 3 questions at once.\n    *Always* present the list of tasks in a structured, ordered format to the user *before* using the delegation tool.\n    To execute/delegate/complete tasks *use the delegation tool*.\n\n    &lt;task_list_proposal_rules&gt;\n        You *must follow* following rules when suggesting a task list:\n        1. Each task must be an step of an step-by-step solution\n        2. All editions related to the same file *must be handled by the same task*\n        3. Task *must* be able to be executed sequentially and reference outcome of previous tasks.\n        4. Tasks outcome must always be file updates/editions\n        5. Specify in agent instructions the resources (links/images) the user gave (including 'img::' if present on images)\n    &lt;/task_list_proposal_rules&gt;\n&lt;/main_specialization_responsibilities&gt;\n\"\"\"\n\n    validation_system_message = \"\"\"\nYou are an AI Agent which has to check if an user request was properly accomplished given the work done by another AI Agent\nYour work is to tell if a task/instruction solved by the agent was fully executed and if the expected outcome was achieved.\n\nAgents can read and write files by themselves, so don't question the agent's actions, if they reported they did something, assume its done, just evaluate their procedure and thinking.\n\n&lt;main_instructions&gt;\n1. If the task/instruction was not fully executed, explain why it was not fully executed, what is missing. Consider any restrictions that were placed on the task. End the response with \"Not fully executed.\"\n2. If the task/instruction was fully executed, explain how the agent achieved the expected outcome. Verify that the outcome matches what was specified for the task. End the response with \"Fully executed.\"\nUse is_task_completed tool\n&lt;/main_instructions&gt;\n\n&lt;task_validation_output_format&gt;\nTask: [Task Objective]\nCompleted: [True/False]\nFeedback: [Feedback or response about task completeness, including adherence to restrictions and achievement of the expected outcome]\n&lt;/task_validation_output_format&gt;\n    \"\"\"\n\n    summarizing_system_message = \"\"\"\nYour role is to summarize the outputs of others agent to solve a request given by the user's task.\nThe summary should be concise and clear.\n\n*Instructions*:\n1. Summarize all task solved in a message aimed for the user who requested the tasks.\n    \"\"\"\n\n    orchestrator_reminder_prompt = \"\"\"\nYou *must follow* following rules when suggesting a task list:\n1. Each task must be an step of an step-by-step solution\n2. All editions related to the same file *must be handled by the same task*\n3. Task *must* be able to be executed sequentially and reference outcome of previous tasks.\n4. Tasks outcome *must always* be file updates/editions\n5. Specify in Task Details the resources (links/images) the user gave (including 'img::' if present on images)\n    \"\"\"\n\n    def __init__(\n        self,\n        agent_config: AgentConfig,\n        stream_parser: XMLStreamParser,\n        extraction_tools=[tools.delegate_tasks, tools.is_task_completed],\n    ):\n        super().__init__(\n            agent_config,\n            stream_parser=stream_parser,\n            extraction_tools=extraction_tools,\n        )\n\n    def get_system_message(self, state: OrchestrationState) -&gt; str:\n        # Default prompt\n        if state[\"status\"] == \"active\":\n            system_prompt = self.system_message\n        elif state[\"status\"] == \"summarizing\":\n            system_prompt = self.summarizing_system_message\n        else:\n            system_prompt = self.validation_system_message\n\n        return build_system_prompt(\n            system_prompt,\n            can_read_files=self.repository_interaction,\n            can_edit_files=not self.read_only and not config.read_only and self.repository_interaction,\n        )\n\n    def get_reminder_prefill(self, state: OrchestrationState) -&gt; str:\n        # Default prompt\n        if state[\"status\"] == \"active\":\n            return super().get_reminder_prefill(state)\n        return \"\"\n\n    def get_tool_choice(self, state: OrchestrationState) -&gt; str:\n        \"\"\"Chooses a the tool to use when calling the llm\"\"\"\n        if state[\"status\"] == \"delegating\":\n            return tools.is_task_completed.name\n        return \"auto\"\n\n    def get_agent_model(self):\n        return get_orchestrator_llm()\n\n    @classmethod\n    def is_agent_response(cls, state: OrchestrationState) -&gt; bool:\n        \"\"\"\n        Verify if the last message in the state is from an agent.\n\n        Args:\n            state (OrchestrationState): The current state containing messages.\n\n        Returns:\n            bool: True if the last message is from an agent, False otherwise.\n        \"\"\"\n        if not state[\"messages\"]:\n            return False\n\n        last_message = state[\"messages\"][-1]\n        # Assuming agent messages are not instances of HumanMessage\n        return not isinstance(last_message, HumanMessage)\n\n    @classmethod\n    def get_current_task(cls, state: OrchestrationState):\n        \"\"\"\n        Get the first task that is not finished from the state.\n\n        Args:\n            state (OrchestrationState): The current state containing tasks.\n\n        Returns:\n            Task: The first unfinished task, or None if all tasks are finished or no tasks exist.\n        \"\"\"\n        if (\n            \"tool_data\" not in state\n            or not state[\"tool_data\"]\n            or tools.delegate_tasks.name not in state[\"tool_data\"]\n            or not state[\"tool_data\"][tools.delegate_tasks.name]\n            or \"task_list\" not in state[\"tool_data\"][tools.delegate_tasks.name]\n        ):\n            return None\n\n        task_list = state[\"tool_data\"][tools.delegate_tasks.name][\"task_list\"]\n        return next((task for task in task_list if not task.get(\"is_finished\", False)), None)\n\n    @classmethod\n    def get_completed_tasks(cls, state: OrchestrationState) -&gt; List[dict]:\n        \"\"\"\n        Get the list of completed tasks from the state.\n\n        Args:\n            state (OrchestrationState): The current state containing tasks.\n\n        Returns:\n            List[dict]: A list of completed tasks with their results.\n        \"\"\"\n        if (\n            \"tool_data\" not in state\n            or not state[\"tool_data\"]\n            or tools.delegate_tasks.name not in state[\"tool_data\"]\n            or not state[\"tool_data\"][tools.delegate_tasks.name]\n            or \"task_list\" not in state[\"tool_data\"][tools.delegate_tasks.name]\n        ):\n            return []\n\n        task_list = state[\"tool_data\"][tools.delegate_tasks.name][\"task_list\"]\n        return [task for task in task_list if task.get(\"is_finished\", False)]\n\n    @classmethod\n    def get_task_list(cls, state: OrchestrationState) -&gt; List[dict]:\n        \"\"\"\n        Get the task list from the state.\n\n        Args:\n            state (OrchestrationState): The current state containing tasks.\n\n        Returns:\n            List[dict]: The task list.\n        \"\"\"\n        if \"tool_data\" not in state or not state[\"tool_data\"] or tools.delegate_tasks.name not in state[\"tool_data\"]:\n            return []\n\n        return state[\"tool_data\"][tools.delegate_tasks.name][\"task_list\"]\n\n    @classmethod\n    def remove_task_list_data(cls, state: OrchestrationState) -&gt; OrchestrationState:\n        \"\"\"Remove the task list data from the state.\"\"\"\n        return {\n            **state,\n            \"tool_data\": {**state[\"tool_data\"], tools.delegate_tasks.name: None},\n        }\n\n    @classmethod\n    def get_agent_instructions(cls, state: OrchestrationState) -&gt; AgentInstructions:\n        return AgentInstructions(**state[\"tool_data\"][tools.delegate_tasks.name])\n\n    @classmethod\n    def validate_current_task_completed(cls, state: OrchestrationState) -&gt; bool:\n        \"\"\"\n        Check if the current task is completed based on the state last tool used.\n\n        Args:\n            state (OrchestrationState): The current state containing task completion status.\n\n        Returns:\n            bool: True if the current task is completed, False otherwise.\n        \"\"\"\n        if \"tool_data\" not in state or not state[\"tool_data\"]:\n            return False\n\n        if tools.is_task_completed.name not in state[\"tool_data\"]:\n            return False\n\n        return state[\"tool_data\"][tools.is_task_completed.name][\"completed\"]\n\n    @classmethod\n    def mark_current_task_as_completed(cls, state: OrchestrationState, response: str) -&gt; OrchestrationState:\n        \"\"\"\n        Mark the current task as completed and return a new state.\n        Adds the llm response to understand in which message the response was marked as completed.\n\n        Args:\n            state (OrchestrationState): The current state.\n            response (str): The response of the llm that completed the task.\n\n        Returns:\n            OrchestrationState: A new state with the current task marked as completed.\n        \"\"\"\n        tool_data = state[\"tool_data\"].copy()\n        if tools.delegate_tasks.name in tool_data:\n            task_list = tool_data[tools.delegate_tasks.name][\"task_list\"]\n            for task in task_list:\n                # Mark first unfinished task as completed\n                if not task.get(\"is_finished\", False):\n                    task[\"is_finished\"] = True\n                    task[\"response\"] = response\n                    break\n\n        return {**state, \"tool_data\": tool_data}\n\n    @classmethod\n    def task_to_instruction(cls, task: dict, state: OrchestrationState) -&gt; str:\n        task_list_data = state[\"tool_data\"][tools.delegate_tasks.name]\n        general_objective = task_list_data[\"general_objective\"]\n\n        completed_tasks = OrchestratorAgent.get_completed_tasks(state)\n        completed_tasks_info = \"\\n\".join([f\"- Completed: {t['objective']}\\n  {t['details']}\" for t in completed_tasks])\n\n        # Get any image for multi-modal llm\n        images = list(filter(lambda res: res.startswith(\"img::\"), task_list_data[\"resources\"]))\n        other_resources = list(filter(lambda res: not res.startswith(\"img::\"), task_list_data[\"resources\"]))\n        images_instruction = \"\"\n        resources_instruction = \"\"\n\n        if images:\n            images_instruction += f\"\\n*Reference images:* {''.join(images)}\"\n        if other_resources:\n            resources_instruction += f\"\\n*Other resources:* {''.join(other_resources)}\"\n\n        return f\"\"\"\\\nYou are requested to solve a specific task related to the objective: {general_objective}.\n\nThese tasks were already completed:\n\n*Context (completed tasks):*\n{completed_tasks_info}\n\n\n*You must execute/complete only the following task:*\n\nObjective: {task[\"objective\"]}\nDetails: {task[\"details\"]}\nRestrictions: {task.get(\"restrictions\", \"No specific restrictions.\")}\nExpected Outcome: {task.get(\"outcome\", \"No specific outcome defined.\")}\n\n*Read all files mentioned in tasks above* for context, then analyze if need to load any else to complete the task.\n\n{images_instruction}\n{resources_instruction}\n\nWrite you answer step by step, using a &lt;thinking&gt; block for analysis your thoughts before giving a response to me using &lt;step&gt; and edit files using &lt;source&gt; blocks.\n\"\"\"\n\n    @classmethod\n    def is_task_list_empty(cls, state: OrchestrationState):\n        \"\"\"\n        Check if the task list is empty in the state.\n\n        Args:\n            state (OrchestrationState): The current state containing tasks.\n\n        Returns:\n            bool: True if the task list is empty, False otherwise.\n        \"\"\"\n        if (\n            \"tool_data\" not in state\n            or not state[\"tool_data\"]\n            or tools.delegate_tasks.name not in state[\"tool_data\"]\n            or not state[\"tool_data\"][tools.delegate_tasks.name]\n        ):\n            return True\n\n        task_list = state[\"tool_data\"][tools.delegate_tasks.name][\"task_list\"]\n        return not task_list\n\n    @classmethod\n    def is_task_list_complete(cls, state: OrchestrationState):\n        \"\"\"\n        Check if the task list is complete in the state.\n\n        Args:\n            state (OrchestrationState): The current state containing tasks.\n\n        Returns:\n            bool: True if the task list is complete, False otherwise.\n        \"\"\"\n\n        task_list = state[\"tool_data\"][tools.delegate_tasks.name][\"task_list\"]\n        return all(task.get(\"is_finished\", False) for task in task_list)\n\n    @classmethod\n    def was_task_validation_tool_used(cls, state: OrchestrationState) -&gt; bool:\n        \"\"\"\n        Check if the validation tool was used in the last message.\n\n        Args:\n            state (OrchestrationState): The current state containing messages.\n\n        Returns:\n            bool: True if the validation tool was used, False otherwise.\n        \"\"\"\n\n        if \"tool_data\" not in state or not state[\"tool_data\"]:\n            return False\n\n        return tools.is_task_completed.name in state[\"tool_data\"]\n</code></pre>"},{"location":"api/agents/#pluscoder.agents.orchestrator.OrchestratorAgent.get_completed_tasks","title":"get_completed_tasks  <code>classmethod</code>","text":"<pre><code>get_completed_tasks(state: OrchestrationState) -&gt; List[dict]\n</code></pre> <p>Get the list of completed tasks from the state.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>OrchestrationState</code> <p>The current state containing tasks.</p> required <p>Returns:</p> Type Description <code>List[dict]</code> <p>List[dict]: A list of completed tasks with their results.</p> Source code in <code>pluscoder/agents/orchestrator.py</code> <pre><code>@classmethod\ndef get_completed_tasks(cls, state: OrchestrationState) -&gt; List[dict]:\n    \"\"\"\n    Get the list of completed tasks from the state.\n\n    Args:\n        state (OrchestrationState): The current state containing tasks.\n\n    Returns:\n        List[dict]: A list of completed tasks with their results.\n    \"\"\"\n    if (\n        \"tool_data\" not in state\n        or not state[\"tool_data\"]\n        or tools.delegate_tasks.name not in state[\"tool_data\"]\n        or not state[\"tool_data\"][tools.delegate_tasks.name]\n        or \"task_list\" not in state[\"tool_data\"][tools.delegate_tasks.name]\n    ):\n        return []\n\n    task_list = state[\"tool_data\"][tools.delegate_tasks.name][\"task_list\"]\n    return [task for task in task_list if task.get(\"is_finished\", False)]\n</code></pre>"},{"location":"api/agents/#pluscoder.agents.orchestrator.OrchestratorAgent.get_current_task","title":"get_current_task  <code>classmethod</code>","text":"<pre><code>get_current_task(state: OrchestrationState)\n</code></pre> <p>Get the first task that is not finished from the state.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>OrchestrationState</code> <p>The current state containing tasks.</p> required <p>Returns:</p> Name Type Description <code>Task</code> <p>The first unfinished task, or None if all tasks are finished or no tasks exist.</p> Source code in <code>pluscoder/agents/orchestrator.py</code> <pre><code>@classmethod\ndef get_current_task(cls, state: OrchestrationState):\n    \"\"\"\n    Get the first task that is not finished from the state.\n\n    Args:\n        state (OrchestrationState): The current state containing tasks.\n\n    Returns:\n        Task: The first unfinished task, or None if all tasks are finished or no tasks exist.\n    \"\"\"\n    if (\n        \"tool_data\" not in state\n        or not state[\"tool_data\"]\n        or tools.delegate_tasks.name not in state[\"tool_data\"]\n        or not state[\"tool_data\"][tools.delegate_tasks.name]\n        or \"task_list\" not in state[\"tool_data\"][tools.delegate_tasks.name]\n    ):\n        return None\n\n    task_list = state[\"tool_data\"][tools.delegate_tasks.name][\"task_list\"]\n    return next((task for task in task_list if not task.get(\"is_finished\", False)), None)\n</code></pre>"},{"location":"api/agents/#pluscoder.agents.orchestrator.OrchestratorAgent.get_task_list","title":"get_task_list  <code>classmethod</code>","text":"<pre><code>get_task_list(state: OrchestrationState) -&gt; List[dict]\n</code></pre> <p>Get the task list from the state.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>OrchestrationState</code> <p>The current state containing tasks.</p> required <p>Returns:</p> Type Description <code>List[dict]</code> <p>List[dict]: The task list.</p> Source code in <code>pluscoder/agents/orchestrator.py</code> <pre><code>@classmethod\ndef get_task_list(cls, state: OrchestrationState) -&gt; List[dict]:\n    \"\"\"\n    Get the task list from the state.\n\n    Args:\n        state (OrchestrationState): The current state containing tasks.\n\n    Returns:\n        List[dict]: The task list.\n    \"\"\"\n    if \"tool_data\" not in state or not state[\"tool_data\"] or tools.delegate_tasks.name not in state[\"tool_data\"]:\n        return []\n\n    return state[\"tool_data\"][tools.delegate_tasks.name][\"task_list\"]\n</code></pre>"},{"location":"api/agents/#pluscoder.agents.orchestrator.OrchestratorAgent.get_tool_choice","title":"get_tool_choice","text":"<pre><code>get_tool_choice(state: OrchestrationState) -&gt; str\n</code></pre> <p>Chooses a the tool to use when calling the llm</p> Source code in <code>pluscoder/agents/orchestrator.py</code> <pre><code>def get_tool_choice(self, state: OrchestrationState) -&gt; str:\n    \"\"\"Chooses a the tool to use when calling the llm\"\"\"\n    if state[\"status\"] == \"delegating\":\n        return tools.is_task_completed.name\n    return \"auto\"\n</code></pre>"},{"location":"api/agents/#pluscoder.agents.orchestrator.OrchestratorAgent.is_agent_response","title":"is_agent_response  <code>classmethod</code>","text":"<pre><code>is_agent_response(state: OrchestrationState) -&gt; bool\n</code></pre> <p>Verify if the last message in the state is from an agent.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>OrchestrationState</code> <p>The current state containing messages.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the last message is from an agent, False otherwise.</p> Source code in <code>pluscoder/agents/orchestrator.py</code> <pre><code>@classmethod\ndef is_agent_response(cls, state: OrchestrationState) -&gt; bool:\n    \"\"\"\n    Verify if the last message in the state is from an agent.\n\n    Args:\n        state (OrchestrationState): The current state containing messages.\n\n    Returns:\n        bool: True if the last message is from an agent, False otherwise.\n    \"\"\"\n    if not state[\"messages\"]:\n        return False\n\n    last_message = state[\"messages\"][-1]\n    # Assuming agent messages are not instances of HumanMessage\n    return not isinstance(last_message, HumanMessage)\n</code></pre>"},{"location":"api/agents/#pluscoder.agents.orchestrator.OrchestratorAgent.is_task_list_complete","title":"is_task_list_complete  <code>classmethod</code>","text":"<pre><code>is_task_list_complete(state: OrchestrationState)\n</code></pre> <p>Check if the task list is complete in the state.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>OrchestrationState</code> <p>The current state containing tasks.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <p>True if the task list is complete, False otherwise.</p> Source code in <code>pluscoder/agents/orchestrator.py</code> <pre><code>@classmethod\ndef is_task_list_complete(cls, state: OrchestrationState):\n    \"\"\"\n    Check if the task list is complete in the state.\n\n    Args:\n        state (OrchestrationState): The current state containing tasks.\n\n    Returns:\n        bool: True if the task list is complete, False otherwise.\n    \"\"\"\n\n    task_list = state[\"tool_data\"][tools.delegate_tasks.name][\"task_list\"]\n    return all(task.get(\"is_finished\", False) for task in task_list)\n</code></pre>"},{"location":"api/agents/#pluscoder.agents.orchestrator.OrchestratorAgent.is_task_list_empty","title":"is_task_list_empty  <code>classmethod</code>","text":"<pre><code>is_task_list_empty(state: OrchestrationState)\n</code></pre> <p>Check if the task list is empty in the state.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>OrchestrationState</code> <p>The current state containing tasks.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <p>True if the task list is empty, False otherwise.</p> Source code in <code>pluscoder/agents/orchestrator.py</code> <pre><code>@classmethod\ndef is_task_list_empty(cls, state: OrchestrationState):\n    \"\"\"\n    Check if the task list is empty in the state.\n\n    Args:\n        state (OrchestrationState): The current state containing tasks.\n\n    Returns:\n        bool: True if the task list is empty, False otherwise.\n    \"\"\"\n    if (\n        \"tool_data\" not in state\n        or not state[\"tool_data\"]\n        or tools.delegate_tasks.name not in state[\"tool_data\"]\n        or not state[\"tool_data\"][tools.delegate_tasks.name]\n    ):\n        return True\n\n    task_list = state[\"tool_data\"][tools.delegate_tasks.name][\"task_list\"]\n    return not task_list\n</code></pre>"},{"location":"api/agents/#pluscoder.agents.orchestrator.OrchestratorAgent.mark_current_task_as_completed","title":"mark_current_task_as_completed  <code>classmethod</code>","text":"<pre><code>mark_current_task_as_completed(\n    state: OrchestrationState, response: str\n) -&gt; OrchestrationState\n</code></pre> <p>Mark the current task as completed and return a new state. Adds the llm response to understand in which message the response was marked as completed.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>OrchestrationState</code> <p>The current state.</p> required <code>response</code> <code>str</code> <p>The response of the llm that completed the task.</p> required <p>Returns:</p> Name Type Description <code>OrchestrationState</code> <code>OrchestrationState</code> <p>A new state with the current task marked as completed.</p> Source code in <code>pluscoder/agents/orchestrator.py</code> <pre><code>@classmethod\ndef mark_current_task_as_completed(cls, state: OrchestrationState, response: str) -&gt; OrchestrationState:\n    \"\"\"\n    Mark the current task as completed and return a new state.\n    Adds the llm response to understand in which message the response was marked as completed.\n\n    Args:\n        state (OrchestrationState): The current state.\n        response (str): The response of the llm that completed the task.\n\n    Returns:\n        OrchestrationState: A new state with the current task marked as completed.\n    \"\"\"\n    tool_data = state[\"tool_data\"].copy()\n    if tools.delegate_tasks.name in tool_data:\n        task_list = tool_data[tools.delegate_tasks.name][\"task_list\"]\n        for task in task_list:\n            # Mark first unfinished task as completed\n            if not task.get(\"is_finished\", False):\n                task[\"is_finished\"] = True\n                task[\"response\"] = response\n                break\n\n    return {**state, \"tool_data\": tool_data}\n</code></pre>"},{"location":"api/agents/#pluscoder.agents.orchestrator.OrchestratorAgent.remove_task_list_data","title":"remove_task_list_data  <code>classmethod</code>","text":"<pre><code>remove_task_list_data(state: OrchestrationState) -&gt; OrchestrationState\n</code></pre> <p>Remove the task list data from the state.</p> Source code in <code>pluscoder/agents/orchestrator.py</code> <pre><code>@classmethod\ndef remove_task_list_data(cls, state: OrchestrationState) -&gt; OrchestrationState:\n    \"\"\"Remove the task list data from the state.\"\"\"\n    return {\n        **state,\n        \"tool_data\": {**state[\"tool_data\"], tools.delegate_tasks.name: None},\n    }\n</code></pre>"},{"location":"api/agents/#pluscoder.agents.orchestrator.OrchestratorAgent.validate_current_task_completed","title":"validate_current_task_completed  <code>classmethod</code>","text":"<pre><code>validate_current_task_completed(state: OrchestrationState) -&gt; bool\n</code></pre> <p>Check if the current task is completed based on the state last tool used.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>OrchestrationState</code> <p>The current state containing task completion status.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the current task is completed, False otherwise.</p> Source code in <code>pluscoder/agents/orchestrator.py</code> <pre><code>@classmethod\ndef validate_current_task_completed(cls, state: OrchestrationState) -&gt; bool:\n    \"\"\"\n    Check if the current task is completed based on the state last tool used.\n\n    Args:\n        state (OrchestrationState): The current state containing task completion status.\n\n    Returns:\n        bool: True if the current task is completed, False otherwise.\n    \"\"\"\n    if \"tool_data\" not in state or not state[\"tool_data\"]:\n        return False\n\n    if tools.is_task_completed.name not in state[\"tool_data\"]:\n        return False\n\n    return state[\"tool_data\"][tools.is_task_completed.name][\"completed\"]\n</code></pre>"},{"location":"api/agents/#pluscoder.agents.orchestrator.OrchestratorAgent.was_task_validation_tool_used","title":"was_task_validation_tool_used  <code>classmethod</code>","text":"<pre><code>was_task_validation_tool_used(state: OrchestrationState) -&gt; bool\n</code></pre> <p>Check if the validation tool was used in the last message.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>OrchestrationState</code> <p>The current state containing messages.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the validation tool was used, False otherwise.</p> Source code in <code>pluscoder/agents/orchestrator.py</code> <pre><code>@classmethod\ndef was_task_validation_tool_used(cls, state: OrchestrationState) -&gt; bool:\n    \"\"\"\n    Check if the validation tool was used in the last message.\n\n    Args:\n        state (OrchestrationState): The current state containing messages.\n\n    Returns:\n        bool: True if the validation tool was used, False otherwise.\n    \"\"\"\n\n    if \"tool_data\" not in state or not state[\"tool_data\"]:\n        return False\n\n    return tools.is_task_completed.name in state[\"tool_data\"]\n</code></pre>"},{"location":"api/config/","title":"Configuration API Reference","text":""},{"location":"api/config/#configuration-utilities","title":"Configuration Utilities","text":""},{"location":"api/config/#pluscoder.config","title":"pluscoder.config","text":""},{"location":"api/tools/","title":"Tools API Reference","text":""},{"location":"api/tools/#core-tools","title":"Core Tools","text":""},{"location":"api/tools/#pluscoder.tools","title":"pluscoder.tools","text":""},{"location":"api/tools/#pluscoder.tools.ask_confirmation","title":"ask_confirmation","text":"<pre><code>ask_confirmation(\n    message: Annotated[str, \"The message to display for confirmation.\"]\n) -&gt; str\n</code></pre> <p>Ask for user confirmation with a custom message.</p> Source code in <code>pluscoder/tools.py</code> <pre><code>@tool\ndef ask_confirmation(\n    message: Annotated[str, \"The message to display for confirmation.\"],\n) -&gt; str:\n    \"\"\"Ask for user confirmation with a custom message.\"\"\"\n    response = io.console.input(f\"[bold green]{message} (y/n): [/bold green]\")\n    if response.lower() == \"y\":\n        return \"Confirmed\"\n    return response\n</code></pre>"},{"location":"api/tools/#pluscoder.tools.convert_to_raw_url","title":"convert_to_raw_url","text":"<pre><code>convert_to_raw_url(url: str) -&gt; str\n</code></pre> <p>Convert repository URL to raw file URL.</p> Source code in <code>pluscoder/tools.py</code> <pre><code>def convert_to_raw_url(url: str) -&gt; str:\n    \"\"\"Convert repository URL to raw file URL.\"\"\"\n    parsed_url = urlparse(url)\n    path_parts = parsed_url.path.split(\"/\")\n\n    if parsed_url.netloc == \"github.com\":\n        if len(path_parts) &gt;= 5 and path_parts[3] == \"blob\":\n            return f\"https://raw.githubusercontent.com/{path_parts[1]}/{path_parts[2]}/{'/'.join(path_parts[4:])}\"\n    elif parsed_url.netloc == \"gitlab.com\" and \"/-/blob/\" in parsed_url.path:\n        return url.replace(\"/-/blob/\", \"/-/raw/\", 1)\n    # elif parsed_url.netloc == \"bitbucket.org\":\n    #     if len(path_parts) &gt;= 5 and path_parts[3] == \"src\":\n    #         return f\"https://bitbucket.org/{path_parts[1]}/{path_parts[2]}/raw/{'/'.join(path_parts[4:])}\"\n    # elif (\n    #     parsed_url.netloc == \"dev.azure.com\"\n    #     and len(path_parts) &gt;= 7\n    #     and path_parts[5] == \"blob\"\n    # ):\n    #     org, project = path_parts[1], path_parts[2]\n    #     repo = path_parts[4]\n    #     branch_and_file = \"/\".join(path_parts[6:])\n    #     return f\"https://dev.azure.com/{org}/{project}/_apis/git/repositories/{repo}/items?path=/{branch_and_file}&amp;api-version=6.0\"\n\n    return url  # Return original URL if not a recognized repository link\n</code></pre>"},{"location":"api/tools/#pluscoder.tools.delegate_tasks","title":"delegate_tasks","text":"<pre><code>delegate_tasks(\n    general_objective: Annotated[str, \"The general objective for all tasks.\"],\n    task_list: Annotated[\n        List[AgentTask],\n        \"List of tasks, each task being a dictionary with 'objective', 'details', 'agent', 'is_finished', 'restrictions', and 'outcome' keys.\",\n    ],\n    resources: Annotated[\n        List[str],\n        \"List of resources specified by the user external to the repository. (url/links/local files)\",\n    ],\n) -&gt; Dict[str, List[AgentTask]]\n</code></pre> <p>Delegates tasks to other agents to execute/complete them. Each task in the task_list must be a dict with 6 values: (objective, details, agent, is_finished, restrictions, outcome). The 'agent' value must be one of: \"developer\". The 'is_finished' value is a boolean indicating whether the task has been completed. The 'restrictions' value is a string describing any limitations or constraints for the task. The 'outcome' value is a string describing the expected result of the task. The 'resources' value contains the list of resources the same exact format the user passed it. Including 'img::' if present.</p> Source code in <code>pluscoder/tools.py</code> <pre><code>@tool\ndef delegate_tasks(\n    general_objective: Annotated[str, \"The general objective for all tasks.\"],\n    task_list: Annotated[\n        List[AgentTask],\n        \"List of tasks, each task being a dictionary with 'objective', 'details', 'agent', 'is_finished', 'restrictions', and 'outcome' keys.\",\n    ],\n    resources: Annotated[\n        List[str],\n        \"List of resources specified by the user external to the repository. (url/links/local files)\",\n    ],\n) -&gt; Dict[str, List[AgentTask]]:\n    \"\"\"\n    Delegates tasks to other agents to execute/complete them. Each task in the task_list must be a dict with 6 values: (objective, details, agent, is_finished, restrictions, outcome).\n    The 'agent' value must be one of: \"developer\".\n    The 'is_finished' value is a boolean indicating whether the task has been completed.\n    The 'restrictions' value is a string describing any limitations or constraints for the task.\n    The 'outcome' value is a string describing the expected result of the task.\n    The 'resources' value contains the list of resources the same exact format the user passed it. Including 'img::' if present.\n    \"\"\"\n    return f\"Task '{general_objective}' about to be delegated. \\n\\n{task_list}\"\n</code></pre>"},{"location":"api/tools/#pluscoder.tools.extract_files","title":"extract_files","text":"<pre><code>extract_files(\n    mentioned_files: Annotated[str, \"Entire list of filenames of file mentions.\"]\n) -&gt; Dict[str, List[Dict[str, str]]]\n</code></pre> <p>Detect and extract all files mentioned with their full paths.</p> Source code in <code>pluscoder/tools.py</code> <pre><code>@tool\ndef extract_files(\n    mentioned_files: Annotated[str, \"Entire list of filenames of file mentions.\"],\n) -&gt; Dict[str, List[Dict[str, str]]]:\n    \"\"\"\n    Detect and extract all files mentioned with their full paths.\n    \"\"\"\n    io.console.print(mentioned_files)\n    return mentioned_files\n</code></pre>"},{"location":"api/tools/#pluscoder.tools.file_detection_with_confirmation","title":"file_detection_with_confirmation","text":"<pre><code>file_detection_with_confirmation(\n    file_path: Annotated[str, \"The path to the file you want to update.\"],\n    content: Annotated[\n        str, \"The entire content including file blocks to be processed.\"\n    ],\n    confirmation: Annotated[str, \"Confirmation status ('YES' or any other value).\"],\n) -&gt; str\n</code></pre> <p>Extract file blocks from content and update the file if confirmed.</p> Source code in <code>pluscoder/tools.py</code> <pre><code>@tool\ndef file_detection_with_confirmation(\n    file_path: Annotated[str, \"The path to the file you want to update.\"],\n    content: Annotated[str, \"The entire content including file blocks to be processed.\"],\n    confirmation: Annotated[str, \"Confirmation status ('YES' or any other value).\"],\n) -&gt; str:\n    \"\"\"\n    Extract file blocks from content and update the file if confirmed.\n    \"\"\"\n    file_blocks = re.findall(r\"(\\S+)\\n```[\\w-]*\\n(.*?)\\n```\", content, re.DOTALL)\n\n    if not file_blocks:\n        return \"No file blocks detected in the content.\"\n\n    for file_name, file_content in file_blocks:\n        if file_name == file_path:\n            if confirmation == \"YES\":\n                return update_file.run({\"file_path\": file_path, \"content\": file_content.strip()})\n            return f\"Update for {file_path} was not confirmed.\"\n\n    return f\"No matching file block found for {file_path}.\"\n</code></pre>"},{"location":"api/tools/#pluscoder.tools.is_task_completed","title":"is_task_completed","text":"<pre><code>is_task_completed(\n    completed: Annotated[bool, \"Boolean indicating whether the task is completed.\"],\n    feedback: Annotated[str, \"Feedback from the agent regarding the task completion.\"],\n) -&gt; Dict[str, bool]\n</code></pre> <p>Extract a boolean indicating whether specified task was completed successfully or not</p> Source code in <code>pluscoder/tools.py</code> <pre><code>@tool\ndef is_task_completed(\n    completed: Annotated[bool, \"Boolean indicating whether the task is completed.\"],\n    feedback: Annotated[str, \"Feedback from the agent regarding the task completion.\"],\n) -&gt; Dict[str, bool]:\n    \"\"\"\n    Extract a boolean indicating whether specified task was completed successfully or not\n    \"\"\"\n    return {\"completed\": completed, \"feedback\": feedback}\n</code></pre>"},{"location":"api/tools/#pluscoder.tools.move_files","title":"move_files","text":"<pre><code>move_files(\n    file_paths: Annotated[\n        List[Dict[str, str]],\n        \"List of dictionaries, each containing 'from' and 'to' keys for the source and destination paths of each file to be moved.\",\n    ]\n) -&gt; str\n</code></pre> <p>Move multiple files from their current locations to new locations.</p> Source code in <code>pluscoder/tools.py</code> <pre><code>@tool\ndef move_files(\n    file_paths: Annotated[\n        List[Dict[str, str]],\n        \"List of dictionaries, each containing 'from' and 'to' keys for the source and destination paths of each file to be moved.\",\n    ],\n) -&gt; str:\n    \"\"\"Move multiple files from their current locations to new locations.\"\"\"\n    results = []\n    for file_path in file_paths:\n        from_path = file_path[\"from\"]\n        to_path = file_path[\"to\"]\n        try:\n            shutil.move(from_path, to_path)\n            results.append(f\"Successfully moved {from_path} to {to_path}\")\n        except Exception as e:\n            results.append(f\"Failed to move {from_path} to {to_path}: {e!s}\")\n\n    success_count = sum(1 for result in results if result.startswith(\"Successfully\"))\n    failure_count = len(results) - success_count\n\n    summary = f\"Moved {success_count} file(s) successfully. {failure_count} file(s) failed to move.\"\n    details = \"\\n\".join(results)\n\n    return f\"{summary}\\n\\nDetails:\\n{details}\"\n</code></pre>"},{"location":"api/tools/#pluscoder.tools.read_file_from_url","title":"read_file_from_url","text":"<pre><code>read_file_from_url(url: Annotated[str, 'The URL of the file to read.']) -&gt; str\n</code></pre> <p>Reads the content of a file given its URL or repository link.</p> Source code in <code>pluscoder/tools.py</code> <pre><code>@tool\ndef read_file_from_url(url: Annotated[str, \"The URL of the file to read.\"]) -&gt; str:\n    \"\"\"Reads the content of a file given its URL or repository link.\"\"\"\n    try:\n        raw_url = convert_to_raw_url(url)\n        response = requests.get(raw_url)\n        response.raise_for_status()\n        content = response.text\n        return f\"Here is the content of the file:\\n\\n{content}\"\n    except requests.RequestException as e:\n        return f\"Error downloading file: {e!s}. It is possible that the given link is not a valid file or url\"\n</code></pre>"},{"location":"api/tools/#pluscoder.tools.read_files","title":"read_files","text":"<pre><code>read_files(\n    file_paths: Annotated[List[str], \"The paths to the files you want to read.\"]\n) -&gt; str\n</code></pre> <p>Read the contents of multiple files at once</p> Source code in <code>pluscoder/tools.py</code> <pre><code>@tool\ndef read_files(\n    file_paths: Annotated[List[str], \"The paths to the files you want to read.\"],\n) -&gt; str:\n    \"\"\"Read the contents of multiple files at once\"\"\"\n    result = \"\"\n    errors = []\n    loaded_files = []\n\n    for file_path in file_paths:\n        try:\n            result += get_formatted_file_content(file_path)\n            loaded_files.append(file_path)\n        except Exception as e:\n            errors.append(f\"Error reading file {file_path}. Maybe the path is wrong or the file never existed: {e!s}\")\n\n    if errors:\n        result += \"\\n\\nErrors:\\n\" + \"\\n\".join(errors)\n\n    io.event(f\"&gt; Added files: {', '.join(loaded_files)}\")\n\n    return \"Here are the files content:\\n\\n\" + result.strip()\n</code></pre>"},{"location":"api/tools/#pluscoder.tools.select_agent","title":"select_agent","text":"<pre><code>select_agent(\n    agent_node: Annotated[\n        Literal[\"domain_stakeholder\", \"planning\", \"developer\", \"domain_expert\"],\n        \"The type of agent to select for the next task.\",\n    ],\n    task: Annotated[str, \"The specific task to be handled by the selected agent.\"],\n) -&gt; str\n</code></pre> <p>Select the best suitable and appropriate agent for handling the specific task.</p> Source code in <code>pluscoder/tools.py</code> <pre><code>@tool\ndef select_agent(\n    agent_node: Annotated[\n        Literal[\"domain_stakeholder\", \"planning\", \"developer\", \"domain_expert\"],\n        \"The type of agent to select for the next task.\",\n    ],\n    task: Annotated[str, \"The specific task to be handled by the selected agent.\"],\n) -&gt; str:\n    \"\"\"\n    Select the best suitable and appropriate agent for handling the specific task.\n    \"\"\"\n    # This tool doesn't need real logic\n    # LLM response fills this tool with all values we define here for future use\n    return f\"{agent_node}:{task}\"\n</code></pre>"},{"location":"api/tools/#pluscoder.tools.update_file","title":"update_file","text":"<pre><code>update_file(\n    file_path: Annotated[str, \"The path to the file you want to update/create.\"],\n    content: Annotated[str, \"New entire content to put in the file.\"],\n) -&gt; str\n</code></pre> <p>Replace the entire content of an existing file or create a new file.</p> Source code in <code>pluscoder/tools.py</code> <pre><code>@tool\ndef update_file(\n    file_path: Annotated[str, \"The path to the file you want to update/create.\"],\n    content: Annotated[str, \"New entire content to put in the file.\"],\n) -&gt; str:\n    \"\"\"Replace the entire content of an existing file or create a new file.\"\"\"\n    try:\n        with open(file_path, \"w\") as file:\n            file.write(content)\n        return f\"File updated successfully at {file_path}\"\n    except Exception as e:\n        return f\"Error updating file: {e!s}\"\n</code></pre>"},{"location":"cloud/","title":"Cloud and Automation Guide","text":""},{"location":"cloud/#overview","title":"Overview","text":"<p>Learn about advanced PlusCoder features for cloud deployment and workflow automation.</p>"},{"location":"cloud/#sections","title":"Sections","text":"<ul> <li>Non-Interactive Mode</li> <li>Workflow Automation</li> </ul>"},{"location":"cloud/non_interactive_mode/","title":"Non-Interactive Mode","text":""},{"location":"cloud/workflow_automation/","title":"Workflow Automation","text":""},{"location":"local/","title":"Local Development Guide","text":""},{"location":"local/#overview","title":"Overview","text":"<p>Explore how to use PlusCoder in local development environments, including CLI usage, configuration, and custom agent creation.</p>"},{"location":"local/#sections","title":"Sections","text":"<ul> <li>Command Line Interface (CLI)</li> <li>Local Configuration</li> <li>Interacting with PlusCoder</li> <li>Creating Custom Agents</li> <li>Tips and Tricks</li> </ul>"},{"location":"local/agents/","title":"Agents","text":""},{"location":"local/cli/","title":"Command Line Interface (CLI)","text":""},{"location":"local/configuration/","title":"Local Configuration","text":""},{"location":"local/talk_to_pluscoder/","title":"Interacting with PlusCoder","text":""},{"location":"local/tips_and_tricks/","title":"Tips and Tricks","text":""},{"location":"local/tools/","title":"Tools","text":""},{"location":"pluscoder/","title":"PlusCoder Documentation","text":""},{"location":"pluscoder/#overview","title":"Overview","text":"<p>Welcome to the PlusCoder documentation. This section provides comprehensive guides for understanding and using the PlusCoder AI-Driven Software Development Workflow.</p>"},{"location":"pluscoder/#sections","title":"Sections","text":"<ul> <li>Installation and Setup</li> <li>Quick Start</li> </ul>"},{"location":"pluscoder/installation_and_setup/","title":"Installation and Setup","text":""},{"location":"pluscoder/introduction/","title":"PlusCoder Documentation","text":""},{"location":"pluscoder/introduction/#overview","title":"Overview","text":"<p>PlusCoder is an AI-powered system that automates the entire software development lifecycle using LLM agents.</p>"},{"location":"pluscoder/introduction/#quick-links","title":"Quick Links","text":"<ul> <li>Quick Start</li> <li>Configuration Guide</li> <li>Custom Agents</li> </ul>"},{"location":"pluscoder/introduction/#key-features","title":"Key Features","text":"<ul> <li>Multi-agent system</li> <li>Automated repository initialization</li> <li>Task-based agent orchestration</li> <li>Flexible configuration</li> <li>Support for multiple LLM models</li> </ul>"},{"location":"pluscoder/introduction/#getting-started","title":"Getting Started","text":"<p>To get started with PlusCoder, please refer to the Quick Start guide.</p>"},{"location":"pluscoder/quick_start/","title":"PlusCoder - Quick Start","text":"<ul> <li>PlusCoder is an AI-powered tool that accelerates software development by assisting with planning, coding, and management tasks.</li> <li>The name \u201d+ Coder\u201d extends beyond just \u201cYou + Coder\u201d\u2014it can be paired with other tools, or CI/CD processes, enhancing them with AI.</li> <li>PlusCoder is a versatile assistant specialized for integration with other systems for streamlined, effortless development.</li> </ul>"},{"location":"pluscoder/quick_start/#installation","title":"Installation","text":"<p>You have tree options to install PlusCoder, depending of the type of user you are:</p>"},{"location":"pluscoder/quick_start/#a-you-coder","title":"a. You + Coder","text":"<ol> <li>install.sh: This is the easiest way to install and PlusCoder. Just run the following command in your terminal. You can select the python or docker version.</li> </ol> <p>:information_source: Note: This script needs Docker or Python 3.12 to be installed and running in your system. This may change in the future. :information_source: Note: If you are using Python, you need to have the right access to the repository.</p> <pre><code>curl -s https://raw.githubusercontent.com/codematos/pluscoder/main/install.sh | bash\n# pluscoder -h\n</code></pre> <p>This script will install PlusCoder in your system, add the and add the <code>pluscoder</code> command to your <code>PATH</code>.</p> <ol> <li>Python: If you prefer to install PlusCoder using Python manually, you can run the following command:</li> </ol> <p>:information_source: Note: This method requires Python 3.12 and the right access to the repository. This may change in the future.</p> <pre><code>conda create -n pc python=3.12\nconda activate pc\npip install git+https://gitlab.com/codematos/pluscoder.git\nalias pluscoder-python=\"$(which python) -m pluscoder\"\n# pluscoder -h\n</code></pre> <ol> <li>Docker: You can also use PlusCoder with Docker manually. Just run the following command:</li> </ol> <pre><code>export PLUSCODER_IMAGE=registry.gitlab.com/codematos/pluscoder:latest\nalias pluscoder-docker=\"docker run --env-file &lt;(env) -v $(pwd):/app -it --rm $PLUSCODER_IMAGE\"\n# pluscoder-docker -h\n</code></pre>"},{"location":"pluscoder/quick_start/#b-contributor","title":"b. Contributor","text":"<p>Follow these steps to install PlusCoder for development with a Makefile and Docker:</p> <ol> <li>Local Development: Install PlusCoder in a virtual environment using the following commands:</li> </ol> <pre><code>make\n</code></pre> <ol> <li>Docker Development: You can also run PlusCoder using Docker with the following command:</li> </ol> <pre><code>make\n</code></pre>"},{"location":"pluscoder/quick_start/#pluscoder-cli","title":"PlusCoder CLI","text":"<p>This section provides an overview of the PlusCoder CLI and how to use it to interact with the PlusCoder system through some examples.</p> <p>Once you set up the necessary credentials, you can start using PlusCoder in your projects.</p> <p>:information_source: Note: You need to have the necessary credentials for AWS Bedrock, Anthropic, OpenAI, or other providers through LLMLite.</p>"},{"location":"pluscoder/quick_start/#basic-usage","title":"Basic Usage","text":"<p>The entry point for PlusCoder is the <code>pluscoder</code> command. You can run it in your terminal to start the PlusCoder CLI.</p> <p>:information_source: Note: PlusCoder only works in a git repository. If you are not in a git repository, you will see an error message.</p> <pre><code># Open a terminal in the project directory\npluscoder\n</code></pre> <p>This command will start the PlusCoder CLI in interactive mode, allowing you to interact with the system using the available agents and features.</p> <p>You can run <code>pluscoder -h</code> for a full list of options for the PlusCoder CLI.</p> <p>But The most important options are:</p> <ul> <li><code>--provider</code>: Provider to use. (<code>aws_bedrock</code>, <code>openai</code>, <code>litellm</code>, <code>anthropic</code>) If not provided, it will use check the configured credentials to select a provider.</li> <li><code>--model</code>: LLM model from the <code>provider</code>. It will use the default model according to the provider.</li> <li><code>--auto_commits</code>: Enable/disable automatic Git commits (default: <code>True</code>)</li> <li><code>--default_agent</code>: Default agent to use. If not provided, you will be prompted to select an agent.</li> </ul>"},{"location":"pluscoder/quick_start/#single-prompt","title":"Single Prompt","text":"<p>You can also run PlusCoder with a single prompt using the <code>--user_input</code> option. This is useful for running a single prompt without entering the interactive mode.</p> <pre><code>pluscoder --user_input \"Create a new feature\" --default_agent \"Developer\"\n</code></pre>"},{"location":"pluscoder/quick_start/#working-with-a-repository","title":"Working with a Repository","text":"<p>The first time you run PlusCoder in a repository, you'll be prompted to initialize the repository through an LLM code base analysis. This process generates a project overview and code guidelines for the repository.</p> <pre><code>pluscoder\n</code></pre>"},{"location":"pluscoder/quick_start/#steps-to-initialize-a-repository-wip","title":"Steps to Initialize a Repository (WIP)","text":"<ol> <li> <p>step 1</p> </li> <li> <p>step 2</p> </li> <li> <p>step 3</p> </li> </ol>"},{"location":"pluscoder/quick_start/#cli-commands","title":"CLI Commands","text":"<p>PlusCoder supports several commands during interaction:</p> Command Description <code>/clear</code> Reset entire chat history. <code>/diff</code> Show last commit diff. <code>/config &lt;key&gt; &lt;value&gt;</code> Override any pluscoder configuration. e.g., <code>/config auto-commits false</code> <code>/undo</code> Revert last commit and remove last message from chat history. <code>/agent</code> Start a conversation with a new agent from scratch. <code>/help</code> Display help information for available commands. <code>/init</code> (Re)Initialize repository understanding the code base to generate project overview and code guidelines. <code>/show_repo</code> Display information about the current repository. <code>/show_repomap</code> Show the repository map with file structure and summaries. <code>/show_config</code> Display the current configuration settings. <code>/custom &lt;prompt_name&gt; &lt;additional instructions&gt;</code> Execute a pre-configured custom prompt command."},{"location":"pluscoder/quick_start/#cli-actions","title":"CLI Actions","text":"<p>PlusCoder provides an enhanced command-line interface for efficient interaction:</p> <p>:warning: Note: Some of these features are not available in Docker.</p> Action Description Input History Press the Up Arrow Recall and reuse previous inputs. Multiline Input Press Ctrl + Return Create a new line for multiline commands. Input Clearing Press Ctrl + C Clear the current text in the input field. File Autocomplete Start typing a filename. Use Tab to alternate suggestions. Get suggestions and autocomplete file paths. Paste Support Paste multiline text directly Use standard paste commands in the input field. Quick Confirmation Use 'y' or 'Y' Quickly confirm prompts or actions. Image Uploading Write <code>img::&lt;url&gt;</code> or <code>img::&lt;local_path&gt;</code> Upload images to the system. Coping Images Press Ctrl + V Copy images and paste it directly into."},{"location":"pluscoder/quick_start/#next-steps","title":"Next Steps","text":"<ul> <li>Read the PlusCoder Configuration documentation to learn how to configure PlusCoder for your projects with the <code>.pluscoder-config.yml</code> file.</li> <li>Read the Adding Custom Agents tutorial to learn how to add custom agents to PlusCoder.</li> <li>Learn the Tips and Tricks to get the most out of PlusCoder.</li> <li>Check out the Workflows+Coder section for an example.</li> </ul>"}]}