{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"<p> Software AI Agents working for you Coding Repository maintenance Brainstorming Planning and more.. </p> <p>     A Python agents framework intended for working in repositories. In simple words, programmable agents that code. </p> <ul> <li>PlusCoder is an AI-powered tool that accelerates software development by assisting with planning, coding, and management tasks.</li> <li>The name \u201d+ Coder\u201d extends beyond just \u201cYou + Coder\u201d\u2014it can be paired with other tools, or CI/CD processes, enhancing them with AI.</li> <li>PlusCoder is a versatile assistant specialized for integration with other systems for streamlined, effortless development.</li> </ul>"},{"location":"#why-to-use-pluscoder","title":"Why to use PlusCoder","text":"<ol> <li>It's just Python: Coding agents are designed to work with large codebases efficiently, and they are fully programmable. You can run them in your development environment or in the cloud, leveraging LLM power in an easy sweep in all your repositories.</li> <li>Customizable and Standardizable: You can write custom company-wide specialized agents, instructions and tools. Allowing your entire team to leverage a single centralized configuration of agents.</li> <li>Chat with agents: You can chat with PlusCoder agents directly working with them as a coding partner with same company-wide configurations and guidelines.</li> <li>Task based workflows: PlusCoder allows you to create customizable and standardizable workflows for automating repetitive coding tasks.</li> <li>Multiple LLM providers: Choose your preferred LLM provider, such as OpenAI, Anthropic, or Cohere, everything supported by LiteLLM.</li> </ol>"},{"location":"#basic-examples","title":"Basic Examples","text":"<p>Instruct agent to work in the current repository:</p> pythonCLIIn-Chat <pre><code>from pluscoder import workflow, build_agents\n\n# Obtain predefined &amp; company-wide agents\nagents = build_agents()\n\n# Select specific agent\ndev_agent = agents.get('developer')\n\n# Runs agent in the current workdir\nworkflow.run(agent=dev_agent, input=\"Write a detailed README.md file specifying develop environment setup using commands present in Makefile\")\n</code></pre> <pre><code>pluscoder --default_agent developer \\\n--auto_confirm yes \\\n--input \"Write a detailed README.md file specifying develop environment setup using commands present in Makefile\"\n</code></pre> <pre><code>&gt; You: Write a detailed README.md file specifying develop environment setup using commands present in Makefile\n</code></pre>"},{"location":"#next-steps","title":"Next steps","text":"<ul> <li>Installation</li> <li>Quick Start</li> <li>Examples</li> </ul>"},{"location":"contributing/","title":"Contributing","text":"<p>We will appreciate any contribution to PlusCoder!</p>"},{"location":"contributing/#start-pluscoding","title":"Start Pluscoding!","text":"<ol> <li> <p>Clone the forked instance of the repository:</p> <pre><code>git clone https://github.com/&lt;your_username&gt;/pluscoder.git\ncd pluscoder\n</code></pre> </li> <li> <p>Be sure of having pip, and install pre-commit:</p> <pre><code>pipx install pre-commit\n</code></pre> </li> <li> <p>Install PlusCoder module and dependencies:</p> <pre><code>make install\n</code></pre> </li> </ol>"},{"location":"installation/","title":"Installation","text":"<ul> <li>Requires Python 3.12.</li> <li>Requires llvm</li> </ul> Any OSMacOS <pre><code>bash -c \"$(wget -O - https://apt.llvm.org/llvm.sh)\"\n</code></pre> <pre><code>brew install llvm@14\n</code></pre> <p>Install PlusCoder as Python library:</p> uvpip <pre><code>uv tool install pluscoder --python 3.12\n</code></pre> <pre><code>pip install pluscoder\n</code></pre> <p>This install everything needed to use PlusCoder with different providers.</p> <p>You can check the installed version with:</p> <pre><code>pluscoder --version\n</code></pre>"},{"location":"installation/#next-steps","title":"Next Steps","text":"<ul> <li>Quick Start Guide</li> <li>Configuration</li> <li>CLI Usage</li> </ul>"},{"location":"installations/","title":"Installations","text":""},{"location":"installations/#installation","title":"Installation","text":"<p>You have tree options to install PlusCoder, depending of the type of user you are:</p>"},{"location":"installations/#a-you-coder","title":"a. You + Coder","text":"<ol> <li>install.sh: This is the easiest way to install and PlusCoder. Just run the following command in your terminal. You can select the python or docker version.</li> </ol> <p>:information_source: Note: This script needs Docker or Python 3.12 to be installed and running in your system. This may change in the future. :information_source: Note: If you are using Python, you need to have the right access to the repository.</p> <pre><code>curl -s https://raw.githubusercontent.com/codematos/pluscoder/main/install.sh | bash\n# pluscoder -h\n</code></pre> <p>This script will install PlusCoder in your system, add the and add the <code>pluscoder</code> command to your <code>PATH</code>.</p> <ol> <li>Python: If you prefer to install PlusCoder using Python manually, you can run the following command:</li> </ol> <p>:information_source: Note: This method requires Python 3.12 and the right access to the repository. This may change in the future.</p> <pre><code>conda create -n pc python=3.12\nconda activate pc\npip install git+https://gitlab.com/codematos/pluscoder.git\nalias pluscoder-python=\"$(which python) -m pluscoder\"\n# pluscoder -h\n</code></pre> <ol> <li>Docker: You can also use PlusCoder with Docker manually. Just run the following command:</li> </ol> <pre><code>export PLUSCODER_IMAGE=registry.gitlab.com/codematos/pluscoder:latest\nalias pluscoder-docker=\"docker run --env-file &lt;(env) -v $(pwd):/app -it --rm $PLUSCODER_IMAGE\"\n# pluscoder-docker -h\n</code></pre>"},{"location":"installations/#b-contributor","title":"b. Contributor","text":""},{"location":"installations/#pluscoder-cli","title":"PlusCoder CLI","text":"<p>This section provides an overview of the PlusCoder CLI and how to use it to interact with the PlusCoder system through some examples.</p> <p>Once you set up the necessary credentials, you can start using PlusCoder in your projects.</p> <p>:information_source: Note: You need to have the necessary credentials for AWS Bedrock, Anthropic, OpenAI, or other providers through LLMLite.</p>"},{"location":"installations/#basic-usage","title":"Basic Usage","text":"<p>The entry point for PlusCoder is the <code>pluscoder</code> command. You can run it in your terminal to start the PlusCoder CLI.</p> <p>:information_source: Note: PlusCoder only works in a git repository. If you are not in a git repository, you will see an error message.</p> <pre><code># Open a terminal in the project directory\npluscoder\n</code></pre> <p>This command will start the PlusCoder CLI in interactive mode, allowing you to interact with the system using the available agents and features.</p> <p>You can run <code>pluscoder -h</code> for a full list of options for the PlusCoder CLI.</p> <p>But The most important options are:</p> <ul> <li><code>--provider</code>: Provider to use. (<code>aws_bedrock</code>, <code>openai</code>, <code>litellm</code>, <code>anthropic</code>) If not provided, it will use check the configured credentials to select a provider.</li> <li><code>--model</code>: LLM model from the <code>provider</code>. It will use the default model according to the provider.</li> <li><code>--auto_commits</code>: Enable/disable automatic Git commits (default: <code>True</code>)</li> <li><code>--default_agent</code>: Default agent to use. If not provided, you will be prompted to select an agent.</li> </ul>"},{"location":"installations/#single-prompt","title":"Single Prompt","text":"<p>You can also run PlusCoder with a single prompt using the <code>--user_input</code> option. This is useful for running a single prompt without entering the interactive mode.</p> <pre><code>pluscoder --user_input \"Create a new feature\" --default_agent \"Developer\"\n</code></pre>"},{"location":"installations/#working-with-a-repository","title":"Working with a Repository","text":"<p>The first time you run PlusCoder in a repository, you'll be prompted to initialize the repository through an LLM code base analysis. This process generates a project overview and code guidelines for the repository.</p> <pre><code>pluscoder\n</code></pre>"},{"location":"installations/#steps-to-initialize-a-repository-wip","title":"Steps to Initialize a Repository (WIP)","text":"<ol> <li> <p>step 1</p> </li> <li> <p>step 2</p> </li> <li> <p>step 3</p> </li> </ol>"},{"location":"installations/#cli-commands","title":"CLI Commands","text":"<p>PlusCoder supports several commands during interaction:</p> Command Description <code>/clear</code> Reset entire chat history. <code>/diff</code> Show last commit diff. <code>/config &lt;key&gt; &lt;value&gt;</code> Override any pluscoder configuration. e.g., <code>/config auto-commits false</code> <code>/undo</code> Revert last commit and remove last message from chat history. <code>/agent</code> Start a conversation with a new agent from scratch. <code>/help</code> Display help information for available commands. <code>/init</code> (Re)Initialize repository understanding the code base to generate project overview and code guidelines. <code>/show_repo</code> Display information about the current repository. <code>/show_repomap</code> Show the repository map with file structure and summaries. <code>/show_config</code> Display the current configuration settings. <code>/custom &lt;prompt_name&gt; &lt;additional instructions&gt;</code> Execute a pre-configured custom prompt command."},{"location":"installations/#cli-actions","title":"CLI Actions","text":"<p>PlusCoder provides an enhanced command-line interface for efficient interaction:</p> <p>:warning: Note: Some of these features are not available in Docker.</p> Action Description Input History Press the Up Arrow Recall and reuse previous inputs. Multiline Input Press Ctrl + Return Create a new line for multiline commands. Input Clearing Press Ctrl + C Clear the current text in the input field. File Autocomplete Start typing a filename. Use Tab to alternate suggestions. Get suggestions and autocomplete file paths. Paste Support Paste multiline text directly Use standard paste commands in the input field. Quick Confirmation Use 'y' or 'Y' Quickly confirm prompts or actions. Image Uploading Write <code>img::&lt;url&gt;</code> or <code>img::&lt;local_path&gt;</code> Upload images to the system. Coping Images Press Ctrl + V Copy images and paste it directly into."},{"location":"installations/#next-steps","title":"Next Steps","text":"<ul> <li>Read the PlusCoder Configuration documentation to learn how to configure PlusCoder for your projects with the <code>.pluscoder-config.yml</code> file.</li> <li>Read the Adding Custom Agents tutorial to learn how to add custom agents to PlusCoder.</li> <li>Learn the Tips and Tricks to get the most out of PlusCoder.</li> <li>Check out the Workflows+Coder section for an example.</li> </ul>"},{"location":"quick_start/","title":"Quick Start","text":"<p>You can run PlusCoder in two ways:</p> <ul> <li>Interactively: Chat with PlusCoder agents in your terminal and instruct them to interact with your local files and directories.</li> <li>Programmatically: Write scripts to interact with PlusCoder using its API. Running it in your local machine or cloud environments.</li> </ul>"},{"location":"quick_start/#interactively","title":"Interactively","text":""},{"location":"quick_start/#basic-chat-with-agents","title":"Basic chat with agents","text":"<p>After installing PlusCoder, start a chat with pre-defined &amp; company-wide agents by running:</p> <pre><code>cd /path/to/your/project\nexport OPENAI_API_KEY=&lt;your_openai_api_key&gt;\npluscoder --model gpt-4o --skip_repo_index\n</code></pre> <p>Info</p> <p>You can also specify any CLI config flag using environment variables or inside pluscoder-config.yaml file. Check configuration options at Configuration or by running <code>pluscoder -h</code>.</p> <p>Info</p> <p>First time you run <code>pluscoder</code> you will be prompted to specify your preferred LLM provider and model.  You can also specify the provider and model using the <code>provider</code> and <code>model</code> options. Check all available providers at the Configuration.</p> <p>Agents by default can read/write local repository files. You can run agents using read-only mode by adding the <code>read_only</code> flag.</p> <pre><code>pluscoder --read_only --skip_repo_index\n</code></pre> <p>Check repository files that agents have access to by running:</p> <pre><code>pluscoder --show_repo\n</code></pre> <p>Or using the in-chat command <code>/show_repo</code>.</p>"},{"location":"quick_start/#optimized-chat-with-indexed-repository","title":"Optimized chat with indexed repository","text":"<p>To optimize the chat experience, we recommend to enable repository indexing. For that just remove the <code>skip_repo_index</code> flag and specify an embedding model using the <code>embedding_model</code> config.</p> <pre><code>export OPENAI_API_KEY=&lt;your_openai_api_key&gt;\npluscoder --model gpt-4o --embedding_model cohere/embed-english-v3.0\n</code></pre> <p>Info</p> <p>Using an embedding model usually incurs additional costs. We recommend using it along <code>repo_exclude_files</code> config option to exclude specific files from indexing.</p>"},{"location":"quick_start/#automated-runs-with-cli","title":"Automated runs with CLI","text":"<p>You can use <code>auto_confirm</code> flag to automatically confirm all prompts. This is useful for automated runs.</p> <pre><code>pluscoder --auto_confirm yes --user_input \"Write unit tests for all functions in the `utils.py` file\"\n</code></pre>"},{"location":"quick_start/#programmatically","title":"Programmatically","text":"<p>PlusCoder provides an API to interact with the system programmatically. Here's an example of how to use it to run an agent in the current workdir with a given input:</p> <pre><code>from pluscoder.agents.core import DeveloperAgent\nfrom pluscoder.type import AgentConfig\nfrom pluscoder.workflow import run_agent\n\n# Select specific agent\ndev_agent: AgentConfig = DeveloperAgent.to_agent_config()\n\n# Runs agent in the current workdir\nrun_agent(agent=dev_agent, input=\"Write a detailed README.md file specifying develop environment setup using commands present in Makefile\")\n</code></pre>"},{"location":"quick_start/#next-steps","title":"Next Steps","text":"<ul> <li>Read the PlusCoder Configuration documentation to learn how to configure PlusCoder for your projects with the <code>.pluscoder-config.yml</code> file.</li> <li>Read the Adding Custom Agents tutorial to learn how to add custom agents to PlusCoder.</li> <li>Learn the Tips and Tricks to get the most out of PlusCoder.</li> <li>Check out the Workflows+Coder section for an example.</li> </ul>"},{"location":"api/agents/","title":"Agents API Reference","text":""},{"location":"api/agents/#base-agent","title":"Base Agent","text":""},{"location":"api/agents/#pluscoder.agents.base","title":"pluscoder.agents.base","text":""},{"location":"api/agents/#pluscoder.agents.base.Agent","title":"Agent","text":"Source code in <code>pluscoder/agents/base.py</code> <pre><code>class Agent:\n    state_schema = OrchestrationState\n\n    def __init__(\n        self, agent_config: AgentConfig, stream_parser: XMLStreamParser, extraction_tools: list[Callable] = []\n    ):\n        self.id = agent_config.id\n        self.name = agent_config.name\n        self.system_message = agent_config.prompt\n        self.tools = [getattr(tools, tool, None) for tool in agent_config.tools if getattr(tools, tool, None)]\n        self.extraction_tools = extraction_tools\n        self.default_context_files = agent_config.default_context_files\n        self.graph = self.get_graph()\n        self.max_deflections = 3\n        self.current_deflection = 0\n        self.repo = Repository(io=io)\n        self.state = None\n        self.disable_reminder = False\n        self.read_only = agent_config.read_only\n        self.description = agent_config.description\n        self.reminder = agent_config.reminder\n        self.repository_interaction = agent_config.repository_interaction\n        self.stream_parser = stream_parser\n        self.updated_files = set()\n\n    def get_context_files(self, state):\n        state_files = state.get(\"context_files\") or []\n        files = [*self.default_context_files, *state_files]\n\n        # remove duplicates\n        return list(set(files))\n\n    def get_context_files_panel(self, files):\n        if files:\n            files_context = \" \".join(files[0:5]) + (f\" (+{len(files) - 5} files)\" if len(files) &gt; 5 else \"\")\n        else:\n            files_context = \"&lt;No files available&gt;\"\n        return f\"&gt; Files context: {files_context}\"\n\n    def get_files_not_in_context(self, state):\n        context_files = set(self.get_context_files(state))\n        all_tracked_files = set(self.repo.get_tracked_files())\n        return sorted(all_tracked_files - context_files)\n\n    def get_files_context_prompt(self, state):\n        files_not_in_context = self.get_files_not_in_context(state)\n\n        prompt = f\"\"\"\nHere is the latest content of those repository files that you already have access to read/edit: \\n\\n{{files_content}}\n\nHere are all repository files you don't have access yet: \\n\\n{files_not_in_context}\n\"\"\"\n\n        if config.use_repomap:\n            prompt += \"\\n\\nHere is the repository map summary so you can handle request better:\\n\\n{repomap}\\n\"\n\n        return prompt\n\n    def get_repomap(self):\n        return self.repo.generate_repomap()\n\n    def get_system_message(self, state: OrchestrationState):\n        return build_system_prompt(\n            self.system_message,\n            can_read_files=self.repository_interaction,\n            can_edit_files=not self.read_only and not config.read_only and self.repository_interaction,\n        )\n\n    def get_reminder_prefill(self, state: OrchestrationState) -&gt; str:\n        prompt = REMINDER_PREFILL_PROMPT\n        if not config.read_only and not self.read_only and self.repository_interaction:\n            prompt += REMINDER_PREFILL_FILE_OPERATIONS_PROMPT\n        if self.reminder:\n            prompt += self.reminder\n        return prompt\n\n    def get_prompt_template_messages(self, state: OrchestrationState):\n        templates_messages = [(\"system\", self.get_system_message(state))]\n\n        if self.repository_interaction:\n            # Context files\n            templates_messages += [\n                (\"user\", self.get_files_context_prompt(state)),\n                AIMessage(content=\"ok\", name=self.id),\n            ]\n        return templates_messages + [\n            (\"placeholder\", \"{messages}\"),\n        ]\n\n    def build_assistant_prompt(self, state: OrchestrationState, deflection_messages: list):\n        # last_message = state[\"messages\"][-1]\n        # check if last message is from a tool\n        # if last_message.type == \"tool\":\n        #     user_message_list = []\n        #     place_holder_messages = state[\"messages\"]\n        # else:\n        #     user_message_list = [state[\"messages\"][-1]]\n        #     place_holder_messages = state[\"messages\"][:-1]\n\n        context_files = self.get_context_files(state)\n        files_content = get_formatted_files_content(context_files)\n\n        # reminders\n        reminder_messages = []\n        if not self.disable_reminder:\n            reminder_messages.append(HumanMessage(content=self.get_reminder_prefill(state), tags=[self.id]))\n\n        # Get stale content version of messages\n        all_messages = state[\"messages\"] + deflection_messages + reminder_messages\n        processed_messages = mask_stale_file_messages(all_messages)\n\n        # assistant_prompt\n        return RunnableMap(\n            {\n                \"messages\": lambda x: processed_messages,\n                \"files_content\": lambda x: files_content,\n                \"repomap\": lambda x: self.get_repomap() if config.use_repomap else \"\",\n            }\n        ) | ChatPromptTemplate.from_messages(self.get_prompt_template_messages(state))\n\n    def get_tool_choice(self, state: OrchestrationState) -&gt; str:\n        \"\"\"Chooses a the tool to use when calling the llm\"\"\"\n        return \"auto\"\n\n    def get_agent_model(self):\n        return get_llm()\n\n    def _stream_events(self, chain, state: OrchestrationState, deflection_messages: List[str]):\n        self.stream_parser.start_stream()\n        first = True\n        gathered = None\n        try:\n            for chunk in chain.stream(\n                {\n                    \"messages\": state[\"messages\"],\n                    \"deflection_messages\": deflection_messages,\n                },\n                {\"callbacks\": [file_callback]},\n            ):\n                if first:\n                    self.stream_parser.stream(chunk.content)\n                    gathered = chunk\n                    first = False\n                else:\n                    self.stream_parser.stream(chunk.content)\n                    gathered = gathered + chunk\n        finally:\n            try:\n                self.stream_parser.close_stream()\n            except Exception as e:\n                print(f\"Error in stream events: {e}\")\n\n        # coerce to message\n        return message_chunk_to_message(cast(BaseMessageChunk, convert_to_messages([gathered])[0]))  # type: ignore\n\n    def _invoke_llm_chain(self, state: OrchestrationState, deflection_messages: List[str] = []):\n        assistant_prompt = self.build_assistant_prompt(state, deflection_messages=deflection_messages)\n        llm = self.get_agent_model()\n        chain: Runnable = assistant_prompt | llm.bind_tools(\n            self.tools + self.extraction_tools, tool_choice=self.get_tool_choice(state)\n        )\n\n        if config.streaming:\n            return self._stream_events(chain, state, deflection_messages)\n\n        # response\n        return chain.invoke(\n            {\n                \"messages\": state[\"messages\"],\n                \"deflection_messages\": deflection_messages,\n            },\n            {\"callbacks\": [file_callback]},\n        )\n\n    def call_agent(self, state):\n        \"\"\"When entering this agent graph, this function is the first node to be called\"\"\"\n\n        self.get_context_files(state)\n        self.disable_reminder = False\n        # io.event(self.get_context_files_panel(context_files))\n\n        interaction_msgs = []\n        post_process_state = {}\n\n        with get_openai_callback() as cb:\n            backoff_time = 2  # Start with 3 seconds\n            while self.current_deflection &lt;= self.max_deflections:\n                try:\n                    llm_response = self._invoke_llm_chain(state, interaction_msgs)\n                    llm_response.tags = [self.id]\n\n                    interaction_msgs.append(llm_response)\n                    post_process_state = self.process_agent_response(state, llm_response)\n                    backoff_time = 2  # Reset backoff time on success\n                    break\n                except AgentException as e:\n                    # Disable sysetem reminders when solving specific errors\n                    self.disable_reminder = True\n\n                    io.log_to_debug_file(\"## AgentException Deflection\")\n                    io.log_to_debug_file(e.message, indent=4)\n\n                    # io.print(f\"Error: {e!s}\")\n                    io.print(\"::re-thinking due an issue:: \", style=\"bold dark_goldenrod\")\n                    if self.current_deflection &lt;= self.max_deflections:\n                        self.current_deflection += 1\n                        interaction_msgs.append(HumanMessage(content=f\"An error ocurred: {e!s}\", tags=[self.id]))\n                        sleep(backoff_time)\n                        backoff_time *= 2  # Exponential backoff\n                except Exception as e:\n                    # Handles unknown exceptions, maybe caused by llm api or wrong state\n                    io.print(f\"An error ocurred when calling model: {e!s}\", style=\"bold red\")\n                    error_traceback = traceback.format_exc()\n                    if config.debug:\n                        io.console.log(f\"Traceback:\\n{error_traceback}\", style=\"bold red\")\n                    io.log_to_debug_file(f\"\\n\\nTraceback:\\n{error_traceback}\", indent=4)\n                    io.log_to_debug_file(\"State:\")\n                    io.log_to_debug_file(message=str(state), indent=4)\n                    io.log_to_debug_file(\"Deflection messages:\")\n                    io.log_to_debug_file(message=str(interaction_msgs), indent=4)\n                    sleep(backoff_time)  # Wait a bit, some api calls need time to recover\n                    interaction_msgs.append(\n                        HumanMessage(content=\"An error occurred. Please try exactly the same again\", tags=[self.id])\n                    )\n                    if self.current_deflection &lt;= self.max_deflections:\n                        self.current_deflection += 1\n                        sleep(backoff_time)\n                        backoff_time *= 2  # Exponential backoff\n\n        # new_state\n        return {\n            \"messages\": interaction_msgs + post_process_state.get(\"messages\", []),\n            \"token_usage\": {\n                \"total_tokens\": cb.total_tokens,\n                \"prompt_tokens\": cb.prompt_tokens,\n                \"completion_tokens\": cb.completion_tokens,\n                \"total_cost\": cb.total_cost,\n            },\n        }\n\n    def agent_router(self, state: OrchestrationState) -&gt; Literal[\"tools\", \"__end__\"]:\n        \"\"\"Edge to chose next node after agent was executed\"\"\"\n        # Ends agent if max deflections reached\n        if self.current_deflection &gt; self.max_deflections:\n            io.console.log(\"Maximum deflections reached. Stopping.\", style=\"bold dark_goldenrod\")\n            return \"__end__\"\n\n        messages = state[\"messages\"]\n        last_message = messages[-1]\n\n        if last_message.tool_calls:\n            return \"tools\"\n\n        return \"__end__\"\n\n    def parse_tool_node(self, state: OrchestrationState):\n        messages = state[\"messages\"]\n\n        # Mark tool message for filtering\n        messages = tag_messages(messages, tags=[self.id], exclude_tagged=True)\n\n        last_message = filter_messages(messages, include_types=[\"ai\"])[-1]\n        # Last message that contains ToolMessage with executed tool data. We need to extract tool args from AIMessage at index -2\n        tool_data = {}\n\n        for tool_call in last_message.tool_calls:\n            # Extract data if extraction tool was used\n            if tool_call[\"name\"] in [tool.name for tool in self.extraction_tools]:\n                tool_data[tool_call[\"name\"]] = tool_call[\"args\"]\n\n        return {\n            **state,\n            \"tool_data\": tool_data,\n            # \"context_files\": state[\"context_files\"] + loaded_files,\n        }\n\n    def parse_tools_router(self, state: OrchestrationState) -&gt; Literal[\"__end__\", \"agent\"]:\n        \"\"\"Edge to decide where to go after all tools data was extracted\"\"\"\n\n        last_message = state[\"messages\"][-1]\n\n        # check if called tool were extraction tools\n        if last_message.type == \"tool\" and last_message.name in [tool.name for tool in self.extraction_tools]:\n            # Extractions tools dosn't need to go back to agent to review them.\n            return \"__end__\"\n\n        # If a normal tool was used, go back to agent to review its output and generate a new response.\n        return \"agent\"\n\n    def get_graph(self):\n        tool_node = ToolNode(self.tools + self.extraction_tools)\n\n        workflow = StateGraph(self.state_schema)\n\n        workflow.add_node(\"agent\", self.call_agent)\n        workflow.add_node(\"tools\", tool_node)\n        workflow.add_node(\"parse_tools\", self.parse_tool_node)\n\n        workflow.add_conditional_edges(\"agent\", self.agent_router)\n        workflow.add_edge(\"tools\", \"parse_tools\")\n        workflow.add_conditional_edges(\"parse_tools\", self.parse_tools_router)\n\n        workflow.set_entry_point(\"agent\")\n\n        return workflow.compile()\n\n    async def graph_node(self, state):\n        \"\"\"Node for handling interactions with the user and other nodes. Called every time a new message is received.\"\"\"\n\n        # Restart deflection counter\n        self.current_deflection = 0\n\n        # Resets updated files of this call\n        self.updated_files = set()\n\n        state_updates = self.graph.invoke(state, {\"callbacks\": [file_callback]})\n\n        io.print(\"\")\n        return {**state, **state_updates, \"messages\": state_updates[\"messages\"]}\n\n    def process_agent_response(self, state, response: AIMessage):\n        # Ignore process until all tools are executed\n        if response.tool_calls:\n            return {}\n\n        # Ignore process until all tools are executed\n        if response.tool_calls:\n            return {}\n\n        # Updated files of the call\n        call_updated_files = self.stream_parser.get_updated_files()\n        self.updated_files.update(call_updated_files)\n\n        error_messages = self.stream_parser.agent_errors\n\n        # check if last message has tool calls to ignore lint/test when files were edited during tool call\n\n        if error_messages:\n            updated_files_msg = (\n                f\"You successfully updated these files: {', '.join(call_updated_files)}, but there are some issues.\\n\"\n                if call_updated_files\n                else \"\"\n            )\n            raise AgentException(\n                \"Some errors occurred when executing your actions:\\n\\n\"\n                + \"\\n\".join(error_messages)\n                + \"\\nPlease review all errors and solve the present issues if you can. Maybe you will need to read files again to understand what is missing or what happened.\"\n                + updated_files_msg\n            )\n\n        if call_updated_files:\n            # Run tests and linting if enabled\n            lint_error = self.repo.run_lint()\n            test_error = self.repo.run_test()\n\n            if lint_error or test_error:\n                error_message = \"Errors found:\\n\"\n                if lint_error:\n                    error_message += f\"Linting: {lint_error}\\n\"\n                if test_error:\n                    error_message += f\"Tests: {test_error}\\n\"\n                raise AgentException(error_message)\n\n        # Updated files during entire agent execution\n        file_editions_msgs = []\n        if self.updated_files:\n            try:\n                if len(self.updated_files) &gt; 1:\n                    io.event(f\"&gt; These files were successfully updated: {', '.join(self.updated_files)}\")\n                # Try to get current event loop\n                loop = asyncio.get_running_loop()\n                # If exists, run in current loop\n                loop.create_task(event_emitter.emit(\"files_updated\", updated_files=self.updated_files))  # noqa: RUF006\n            except RuntimeError:\n                # If no loop exists, create new one\n                asyncio.run(event_emitter.emit(\"files_updated\", updated_files=self.updated_files))\n            finally:\n                file_editions_msgs = [build_file_editions_tool_message(list(self.updated_files), agent_id=self.id)]\n                self.updated_files = set()\n\n        # Add file editions tool message so agent can understand files was updated successfully\n        return {\"messages\": file_editions_msgs}\n</code></pre>"},{"location":"api/agents/#pluscoder.agents.base.Agent.agent_router","title":"agent_router","text":"<pre><code>agent_router(state: OrchestrationState) -&gt; Literal['tools', '__end__']\n</code></pre> <p>Edge to chose next node after agent was executed</p> Source code in <code>pluscoder/agents/base.py</code> <pre><code>def agent_router(self, state: OrchestrationState) -&gt; Literal[\"tools\", \"__end__\"]:\n    \"\"\"Edge to chose next node after agent was executed\"\"\"\n    # Ends agent if max deflections reached\n    if self.current_deflection &gt; self.max_deflections:\n        io.console.log(\"Maximum deflections reached. Stopping.\", style=\"bold dark_goldenrod\")\n        return \"__end__\"\n\n    messages = state[\"messages\"]\n    last_message = messages[-1]\n\n    if last_message.tool_calls:\n        return \"tools\"\n\n    return \"__end__\"\n</code></pre>"},{"location":"api/agents/#pluscoder.agents.base.Agent.call_agent","title":"call_agent","text":"<pre><code>call_agent(state)\n</code></pre> <p>When entering this agent graph, this function is the first node to be called</p> Source code in <code>pluscoder/agents/base.py</code> <pre><code>def call_agent(self, state):\n    \"\"\"When entering this agent graph, this function is the first node to be called\"\"\"\n\n    self.get_context_files(state)\n    self.disable_reminder = False\n    # io.event(self.get_context_files_panel(context_files))\n\n    interaction_msgs = []\n    post_process_state = {}\n\n    with get_openai_callback() as cb:\n        backoff_time = 2  # Start with 3 seconds\n        while self.current_deflection &lt;= self.max_deflections:\n            try:\n                llm_response = self._invoke_llm_chain(state, interaction_msgs)\n                llm_response.tags = [self.id]\n\n                interaction_msgs.append(llm_response)\n                post_process_state = self.process_agent_response(state, llm_response)\n                backoff_time = 2  # Reset backoff time on success\n                break\n            except AgentException as e:\n                # Disable sysetem reminders when solving specific errors\n                self.disable_reminder = True\n\n                io.log_to_debug_file(\"## AgentException Deflection\")\n                io.log_to_debug_file(e.message, indent=4)\n\n                # io.print(f\"Error: {e!s}\")\n                io.print(\"::re-thinking due an issue:: \", style=\"bold dark_goldenrod\")\n                if self.current_deflection &lt;= self.max_deflections:\n                    self.current_deflection += 1\n                    interaction_msgs.append(HumanMessage(content=f\"An error ocurred: {e!s}\", tags=[self.id]))\n                    sleep(backoff_time)\n                    backoff_time *= 2  # Exponential backoff\n            except Exception as e:\n                # Handles unknown exceptions, maybe caused by llm api or wrong state\n                io.print(f\"An error ocurred when calling model: {e!s}\", style=\"bold red\")\n                error_traceback = traceback.format_exc()\n                if config.debug:\n                    io.console.log(f\"Traceback:\\n{error_traceback}\", style=\"bold red\")\n                io.log_to_debug_file(f\"\\n\\nTraceback:\\n{error_traceback}\", indent=4)\n                io.log_to_debug_file(\"State:\")\n                io.log_to_debug_file(message=str(state), indent=4)\n                io.log_to_debug_file(\"Deflection messages:\")\n                io.log_to_debug_file(message=str(interaction_msgs), indent=4)\n                sleep(backoff_time)  # Wait a bit, some api calls need time to recover\n                interaction_msgs.append(\n                    HumanMessage(content=\"An error occurred. Please try exactly the same again\", tags=[self.id])\n                )\n                if self.current_deflection &lt;= self.max_deflections:\n                    self.current_deflection += 1\n                    sleep(backoff_time)\n                    backoff_time *= 2  # Exponential backoff\n\n    # new_state\n    return {\n        \"messages\": interaction_msgs + post_process_state.get(\"messages\", []),\n        \"token_usage\": {\n            \"total_tokens\": cb.total_tokens,\n            \"prompt_tokens\": cb.prompt_tokens,\n            \"completion_tokens\": cb.completion_tokens,\n            \"total_cost\": cb.total_cost,\n        },\n    }\n</code></pre>"},{"location":"api/agents/#pluscoder.agents.base.Agent.get_tool_choice","title":"get_tool_choice","text":"<pre><code>get_tool_choice(state: OrchestrationState) -&gt; str\n</code></pre> <p>Chooses a the tool to use when calling the llm</p> Source code in <code>pluscoder/agents/base.py</code> <pre><code>def get_tool_choice(self, state: OrchestrationState) -&gt; str:\n    \"\"\"Chooses a the tool to use when calling the llm\"\"\"\n    return \"auto\"\n</code></pre>"},{"location":"api/agents/#pluscoder.agents.base.Agent.graph_node","title":"graph_node  <code>async</code>","text":"<pre><code>graph_node(state)\n</code></pre> <p>Node for handling interactions with the user and other nodes. Called every time a new message is received.</p> Source code in <code>pluscoder/agents/base.py</code> <pre><code>async def graph_node(self, state):\n    \"\"\"Node for handling interactions with the user and other nodes. Called every time a new message is received.\"\"\"\n\n    # Restart deflection counter\n    self.current_deflection = 0\n\n    # Resets updated files of this call\n    self.updated_files = set()\n\n    state_updates = self.graph.invoke(state, {\"callbacks\": [file_callback]})\n\n    io.print(\"\")\n    return {**state, **state_updates, \"messages\": state_updates[\"messages\"]}\n</code></pre>"},{"location":"api/agents/#pluscoder.agents.base.Agent.parse_tools_router","title":"parse_tools_router","text":"<pre><code>parse_tools_router(state: OrchestrationState) -&gt; Literal['__end__', 'agent']\n</code></pre> <p>Edge to decide where to go after all tools data was extracted</p> Source code in <code>pluscoder/agents/base.py</code> <pre><code>def parse_tools_router(self, state: OrchestrationState) -&gt; Literal[\"__end__\", \"agent\"]:\n    \"\"\"Edge to decide where to go after all tools data was extracted\"\"\"\n\n    last_message = state[\"messages\"][-1]\n\n    # check if called tool were extraction tools\n    if last_message.type == \"tool\" and last_message.name in [tool.name for tool in self.extraction_tools]:\n        # Extractions tools dosn't need to go back to agent to review them.\n        return \"__end__\"\n\n    # If a normal tool was used, go back to agent to review its output and generate a new response.\n    return \"agent\"\n</code></pre>"},{"location":"api/agents/#core-agents","title":"Core Agents","text":""},{"location":"api/agents/#pluscoder.agents.core","title":"pluscoder.agents.core","text":""},{"location":"api/agents/#pluscoder.agents.core.AgentDefinition","title":"AgentDefinition","text":"Source code in <code>pluscoder/agents/core.py</code> <pre><code>class AgentDefinition:\n    @classmethod\n    def to_agent_config(cls, **kwargs):\n        \"\"\"Creates an AgentConfig instance from the AgentDefinition class.\n\n        You can override any AgentConfig value to customize the agent configuration.\n\n        Check the AgentConfig class for more details on the available fields.\n\n        Returns:\n            _type_: _description_\n        \"\"\"\n        return AgentConfig(\n            **{\n                \"id\": cls.id,\n                \"name\": cls.name,\n                \"description\": cls.description,\n                \"suggestions\": cls.suggestions,\n                \"prompt\": cls.specialization_prompt,\n                \"repository_interaction\": True,\n                \"read_only\": False,\n                \"reminder\": \"\",\n                \"default_context_files\": [],\n                **kwargs,\n            },\n        )\n</code></pre>"},{"location":"api/agents/#pluscoder.agents.core.AgentDefinition.to_agent_config","title":"to_agent_config  <code>classmethod</code>","text":"<pre><code>to_agent_config(**kwargs)\n</code></pre> <p>Creates an AgentConfig instance from the AgentDefinition class.</p> <p>You can override any AgentConfig value to customize the agent configuration.</p> <p>Check the AgentConfig class for more details on the available fields.</p> <p>Returns:</p> Name Type Description <code>_type_</code> <p>description</p> Source code in <code>pluscoder/agents/core.py</code> <pre><code>@classmethod\ndef to_agent_config(cls, **kwargs):\n    \"\"\"Creates an AgentConfig instance from the AgentDefinition class.\n\n    You can override any AgentConfig value to customize the agent configuration.\n\n    Check the AgentConfig class for more details on the available fields.\n\n    Returns:\n        _type_: _description_\n    \"\"\"\n    return AgentConfig(\n        **{\n            \"id\": cls.id,\n            \"name\": cls.name,\n            \"description\": cls.description,\n            \"suggestions\": cls.suggestions,\n            \"prompt\": cls.specialization_prompt,\n            \"repository_interaction\": True,\n            \"read_only\": False,\n            \"reminder\": \"\",\n            \"default_context_files\": [],\n            **kwargs,\n        },\n    )\n</code></pre>"},{"location":"api/agents/#orchestrator-agent","title":"Orchestrator Agent","text":""},{"location":"api/agents/#pluscoder.agents.orchestrator","title":"pluscoder.agents.orchestrator","text":""},{"location":"api/agents/#pluscoder.agents.orchestrator.OrchestratorAgent","title":"OrchestratorAgent","text":"<p>               Bases: <code>Agent</code>, <code>AgentDefinition</code></p> Source code in <code>pluscoder/agents/orchestrator.py</code> <pre><code>class OrchestratorAgent(Agent, AgentDefinition):\n    id = \"orchestrator\"\n    name = \"Orchestrator\"\n    description = \"Design and run complex plan delegating it to other agents\"\n    suggestions = [\n        \"Plan implementation of SSO with Keycloak and JWT auth\",\n        \"Create roadmap for migrating monolith to microservices\",\n        \"Design implementation of AWS S3 file upload system\",\n        \"Plan Kubernetes deployment with monitoring setup\",\n    ]\n    specialization_prompt = \"\"\"\n*SPECIALIZATION INSTRUCTIONS*:\nYou are the Orchestrator Agent, your role is to understand user requirements to generate/plan a proper list of task to solve those requirements with the help of specialized Pluscoder AI Agents.\n\n&lt;specialization_context&gt;\n1. Other Pluscoder agents are mostly like you. Then know and have access to the same repository and can work over it, creating files, analyzing, summarizing, coding, document, etc\n2. They have the same limitations as you. They can't run bash commands for example.\n3. They can read files from urls or from user SO/repository\n4. They don't have memory, when delegating tasks they will only have access to the task list you provide to them.\n5. They can visually read images if these starts with img::&lt;image_path_or_utl&gt;, same as you can do, otherwise they will only see the path\n&lt;/specialization_context&gt;\n\n&lt;available_agents_to_delegate_tasks&gt;\n*Available Agents*:\n- Developer Agent: For writing code, documentation, tests, etc.\n&lt;/available_agents_to_delegate_tasks&gt;\n\n&lt;task_item_structure&gt;\n[] '&lt;task name&gt;'\n   'Objective': &lt;task objective&gt;\n   'Details': &lt;task details&gt; Details of the task to complete. Always include file paths to give more context, and functions/class/method names. Always include references to files edited by previous tasks to explain how tasks are related.\n   'Agent': &lt;agent name&gt; Agent who is responsible for this task.\n   'Restrictions': &lt;task restrictions&gt; Any limitations or constraints for the task.\n   'Outcome': &lt;expected outcome&gt; The expected result (file updates) of completing this task.\n&lt;/task_item_structure&gt;\n\n&lt;task_list_examples&gt;\n* All following tasks are examples, do not use them as a reference. Create your own list of tasks and follow the given instructions to complete them *\n    &lt;example requirement=\"add a cli option to display weather information\"&gt;\n        'General objective': Implement Weather Feature\n\n        [ ] 'Implement Weather Data Fetching and CLI Command'\n        'Objective': Add functionality to fetch current weather data from an API and create a CLI command\n        'Details': Create a new file `code/weather.py`. Implement a `WeatherService` class with a method `get_current_weather(city: str)` that fetches weather data for a given city using an external API (e.g., OpenWeatherMap). Use the `requests` library for HTTP calls. In the same file, implement a CLI command `weather` that uses this service. Update `code/commands.py` to include the new weather command in the command parser.\n        'Agent': Developer\n        'Restrictions': Use only the `requests` library for API calls. Ensure proper error handling for API requests.\n        'Outcome': New file `code/weather.py` with `WeatherService` class and CLI command implementation. Updated `code/commands.py` with new weather command added to the parser.\n\n        [ ] 'Create Unit Tests for Weather Feature'\n        'Objective': Implement unit tests for the new weather functionality\n        'Details': Create a new file `tests/test_weather.py`. Write unit tests to verify the correct functioning of the `WeatherService` class, its `get_current_weather()` method, and the CLI command. Include tests for successful API calls, error handling, and edge cases. Use mocking to avoid actual API calls during testing.\n        'Agent': Developer\n        'Restrictions': Use pytest for writing tests. Ensure all tests are independent and do not rely on external services.\n        'Outcome': New file `tests/test_weather.py` with comprehensive unit tests for the weather feature.\n\n        [ ] 'Update Project Documentation'\n        'Objective': Document the new weather feature in project files\n        'Details': Update `PROJECT_OVERVIEW.md` to include information about the new weather feature. Add a section in `README.md` explaining how to use the new weather command, including any required API keys or configuration, and provide an example of the output.\n        'Agent': Developer\n        'Restrictions': Ensure documentation is clear and concise. Include any setup steps required for the weather API.\n        'Outcome': Updated `PROJECT_OVERVIEW.md` and `README.md` files with new sections detailing the weather feature.\n    &lt;/example&gt;\n    &lt;example requirement=\"allow client to process csv data\"&gt;\n        'General objective': Implement Data Processing Feature\n\n        [ ] 'Implement CSV Data Processing and CLI Interface'\n        'Objective': Add functionality to process CSV files, calculate statistics, and create a CLI interface\n        'Details': Create a new file `code/data_processor.py`. Implement a `CSVProcessor` class with a method `calculate_stats(file_path: str)` that reads a CSV file, calculates basic statistics (mean, median, mode) for numeric columns, and returns the results. Use the `pandas` library for data processing. In the same file, implement a CLI command `process-csv` that uses this processor. Update `code/commands.py` to include the new CSV processing command in the command parser.\n        'Agent': Developer\n        'Restrictions': Use only the `pandas` library for CSV processing. Ensure proper error handling for file operations and data processing.\n        'Outcome': New file `code/data_processor.py` with `CSVProcessor` class and CLI command implementation. Updated `code/commands.py` with new CSV processing command added to the parser.\n\n        [ ] 'Create Unit Tests for CSV Processing'\n        'Objective': Implement unit tests for the new CSV processing functionality\n        'Details': Create a new file `tests/test_csv_processor.py`. Write unit tests to verify the correct functioning of the `CSVProcessor` class, its `calculate_stats()` method, and the CLI command. Include tests for various CSV formats, error handling, and edge cases. Create sample CSV files in a `tests/data/` directory to use in these tests.\n        'Agent': Developer\n        'Restrictions': Use pytest for writing tests. Ensure all tests are independent and use mock data.\n        'Outcome': New file `tests/test_csv_processor.py` with comprehensive unit tests for the CSV processing feature. New directory `tests/data/` with sample CSV files for testing.\n\n        [ ] 'Update Project Documentation for CSV Processing'\n        'Objective': Document the new CSV processing feature in project files\n        'Details': Update `PROJECT_OVERVIEW.md` to include information about the new CSV processing feature. Add a section in `README.md` explaining how to use the new CSV processing command, including expected CSV format, the statistics calculated, and provide an example command with sample output.\n        'Agent': Developer\n        'Restrictions': Ensure documentation is clear and concise. Include any dependencies required for the CSV processing feature.\n        'Outcome': Updated `PROJECT_OVERVIEW.md` and `README.md` files with new sections detailing the CSV processing feature.\n    &lt;/example&gt;\n    &lt;example requirement=\"generate an overview documentation of this backend and frontend project at PROJECT_OVERVIEW.md\"&gt;\n        Example 3: Project Analysis and Overview\n\n        [ ] 'Analyze Project Structure and Components'\n        'Objective': Examine and summarize the project's backend, frontend, and integration components\n        'Details': Analyze the following files:\n        - Backend: `src/server/app.js`, `src/server/models/index.js`, `src/server/controllers/index.js`\n        - Frontend: `src/client/App.js`, `src/client/components/index.js`, `src/client/pages/index.js`\n        - Integration: `src/server/config/database.js`, `src/server/routes/api.js`, `src/client/services/api.js`\n        Summarize the findings in a single file `temp_project_analysis.md`, organizing the information into sections for backend, frontend, and integration.\n        'Agent': Developer\n        'Restrictions': Focus on high-level architecture and key components. Do not include low-level implementation details.\n        'Outcome': New file `temp_project_analysis.md` with a comprehensive summary of the project's structure and components.\n\n        [ ] 'Generate Structured Project Overview'\n        'Objective': Create a comprehensive, structured overview of the project based on the analysis\n        'Details': Using the information from `temp_project_analysis.md`, create a new file `PROJECT_OVERVIEW.md` in the project root. Organize the information into sections such as \"Backend Architecture\", \"Frontend Structure\", \"Database Schema\", \"API Integration\", and \"Key Features\". Include relevant file paths, main components, and brief explanations of their purposes. Ensure the document provides a clear, high-level understanding of the project's structure and functionality.\n        'Agent': Developer\n        'Restrictions': The overview should be concise yet comprehensive. Use clear headings and subheadings for easy navigation.\n        'Outcome': New file `PROJECT_OVERVIEW.md` with a structured, comprehensive overview of the project. Deletion of the temporary `temp_project_analysis.md` file.\n    &lt;/example&gt;\n&lt;/task_list_examples&gt;\n\n&lt;main_specialization_responsibilities&gt;\n    Ask key questions about the requirement to understand the user vision and goals deeply, including technical aspects &amp; non-technical aspects.\n    Simple requirements requires less (or no) questions than complex ones. Choose key questions that will help you create a comprehensive list of tasks.\n\n    Do not propose a list of task until you understand the user requirements deeply through asking detailed questions. *Do not* ask more than 3 questions at once.\n    *Always* present the list of tasks in a structured, ordered format to the user *before* using the delegation tool.\n    To execute/delegate/complete tasks *use the delegation tool*.\n\n    &lt;task_list_proposal_rules&gt;\n        You *must follow* following rules when suggesting a task list:\n        1. Each task must be an step of an step-by-step solution\n        2. All editions related to the same file *must be handled by the same task*\n        3. Task *must* be able to be executed sequentially and reference outcome of previous tasks.\n        4. Tasks outcome must always be file updates/editions\n        5. Specify in agent instructions the resources (links/images) the user gave (including 'img::' if present on images)\n    &lt;/task_list_proposal_rules&gt;\n&lt;/main_specialization_responsibilities&gt;\n\"\"\"\n\n    validation_system_message = \"\"\"\nYou are an AI Agent which has to check if an user request was properly accomplished given the work done by another AI Agent\nYour work is to tell if a task/instruction solved by the agent was fully executed and if the expected outcome was achieved.\n\nAgents can read and write files by themselves, so don't question the agent's actions, if they reported they did something, assume its done, just evaluate their procedure and thinking.\n\n&lt;main_instructions&gt;\n1. If the task/instruction was not fully executed, explain why it was not fully executed, what is missing. Consider any restrictions that were placed on the task. End the response with \"Not fully executed.\"\n2. If the task/instruction was fully executed, explain how the agent achieved the expected outcome. Verify that the outcome matches what was specified for the task. End the response with \"Fully executed.\"\nUse is_task_completed tool\n&lt;/main_instructions&gt;\n\n&lt;task_validation_output_format&gt;\nTask: [Task Objective]\nCompleted: [True/False]\nFeedback: [Feedback or response about task completeness, including adherence to restrictions and achievement of the expected outcome]\n&lt;/task_validation_output_format&gt;\n    \"\"\"\n\n    summarizing_system_message = \"\"\"\nYour role is to summarize the outputs of others agent to solve a request given by the user's task.\nThe summary should be concise and clear.\n\n*Instructions*:\n1. Summarize all task solved in a message aimed for the user who requested the tasks.\n    \"\"\"\n\n    orchestrator_reminder_prompt = \"\"\"\nYou *must follow* following rules when suggesting a task list:\n1. Each task must be an step of an step-by-step solution\n2. All editions related to the same file *must be handled by the same task*\n3. Task *must* be able to be executed sequentially and reference outcome of previous tasks.\n4. Tasks outcome *must always* be file updates/editions\n5. Specify in Task Details the resources (links/images) the user gave (including 'img::' if present on images)\n    \"\"\"\n\n    def __init__(\n        self,\n        agent_config: AgentConfig,\n        stream_parser: XMLStreamParser,\n        extraction_tools=[tools.delegate_tasks, tools.is_task_completed],\n    ):\n        super().__init__(\n            agent_config,\n            stream_parser=stream_parser,\n            extraction_tools=extraction_tools,\n        )\n\n    def get_system_message(self, state: OrchestrationState) -&gt; str:\n        # Default prompt\n        if state[\"status\"] == \"active\":\n            system_prompt = self.system_message\n        elif state[\"status\"] == \"summarizing\":\n            system_prompt = self.summarizing_system_message\n        else:\n            system_prompt = self.validation_system_message\n\n        return build_system_prompt(\n            system_prompt,\n            can_read_files=self.repository_interaction,\n            can_edit_files=not self.read_only and not config.read_only and self.repository_interaction,\n        )\n\n    def get_reminder_prefill(self, state: OrchestrationState) -&gt; str:\n        # Default prompt\n        if state[\"status\"] == \"active\":\n            return super().get_reminder_prefill(state)\n        return \"\"\n\n    def get_tool_choice(self, state: OrchestrationState) -&gt; str:\n        \"\"\"Chooses a the tool to use when calling the llm\"\"\"\n        if state[\"status\"] == \"delegating\":\n            return tools.is_task_completed.name\n        return \"auto\"\n\n    def get_agent_model(self):\n        return get_orchestrator_llm()\n\n    @classmethod\n    def is_agent_response(cls, state: OrchestrationState) -&gt; bool:\n        \"\"\"\n        Verify if the last message in the state is from an agent.\n\n        Args:\n            state (OrchestrationState): The current state containing messages.\n\n        Returns:\n            bool: True if the last message is from an agent, False otherwise.\n        \"\"\"\n        if not state[\"messages\"]:\n            return False\n\n        last_message = state[\"messages\"][-1]\n        # Assuming agent messages are not instances of HumanMessage\n        return not isinstance(last_message, HumanMessage)\n\n    @classmethod\n    def get_current_task(cls, state: OrchestrationState):\n        \"\"\"\n        Get the first task that is not finished from the state.\n\n        Args:\n            state (OrchestrationState): The current state containing tasks.\n\n        Returns:\n            Task: The first unfinished task, or None if all tasks are finished or no tasks exist.\n        \"\"\"\n        if (\n            \"tool_data\" not in state\n            or not state[\"tool_data\"]\n            or tools.delegate_tasks.name not in state[\"tool_data\"]\n            or not state[\"tool_data\"][tools.delegate_tasks.name]\n            or \"task_list\" not in state[\"tool_data\"][tools.delegate_tasks.name]\n        ):\n            return None\n\n        task_list = state[\"tool_data\"][tools.delegate_tasks.name][\"task_list\"]\n        return next((task for task in task_list if not task.get(\"is_finished\", False)), None)\n\n    @classmethod\n    def get_completed_tasks(cls, state: OrchestrationState) -&gt; List[dict]:\n        \"\"\"\n        Get the list of completed tasks from the state.\n\n        Args:\n            state (OrchestrationState): The current state containing tasks.\n\n        Returns:\n            List[dict]: A list of completed tasks with their results.\n        \"\"\"\n        if (\n            \"tool_data\" not in state\n            or not state[\"tool_data\"]\n            or tools.delegate_tasks.name not in state[\"tool_data\"]\n            or not state[\"tool_data\"][tools.delegate_tasks.name]\n            or \"task_list\" not in state[\"tool_data\"][tools.delegate_tasks.name]\n        ):\n            return []\n\n        task_list = state[\"tool_data\"][tools.delegate_tasks.name][\"task_list\"]\n        return [task for task in task_list if task.get(\"is_finished\", False)]\n\n    @classmethod\n    def get_task_list(cls, state: OrchestrationState) -&gt; List[dict]:\n        \"\"\"\n        Get the task list from the state.\n\n        Args:\n            state (OrchestrationState): The current state containing tasks.\n\n        Returns:\n            List[dict]: The task list.\n        \"\"\"\n        if \"tool_data\" not in state or not state[\"tool_data\"] or tools.delegate_tasks.name not in state[\"tool_data\"]:\n            return []\n\n        return state[\"tool_data\"][tools.delegate_tasks.name][\"task_list\"]\n\n    @classmethod\n    def remove_task_list_data(cls, state: OrchestrationState) -&gt; OrchestrationState:\n        \"\"\"Remove the task list data from the state.\"\"\"\n        return {\n            **state,\n            \"tool_data\": {**state[\"tool_data\"], tools.delegate_tasks.name: None},\n        }\n\n    @classmethod\n    def get_agent_instructions(cls, state: OrchestrationState) -&gt; AgentInstructions:\n        return AgentInstructions(**state[\"tool_data\"][tools.delegate_tasks.name])\n\n    @classmethod\n    def validate_current_task_completed(cls, state: OrchestrationState) -&gt; bool:\n        \"\"\"\n        Check if the current task is completed based on the state last tool used.\n\n        Args:\n            state (OrchestrationState): The current state containing task completion status.\n\n        Returns:\n            bool: True if the current task is completed, False otherwise.\n        \"\"\"\n        if \"tool_data\" not in state or not state[\"tool_data\"]:\n            return False\n\n        if tools.is_task_completed.name not in state[\"tool_data\"]:\n            return False\n\n        return state[\"tool_data\"][tools.is_task_completed.name][\"completed\"]\n\n    @classmethod\n    def mark_current_task_as_completed(cls, state: OrchestrationState, response: str) -&gt; OrchestrationState:\n        \"\"\"\n        Mark the current task as completed and return a new state.\n        Adds the llm response to understand in which message the response was marked as completed.\n\n        Args:\n            state (OrchestrationState): The current state.\n            response (str): The response of the llm that completed the task.\n\n        Returns:\n            OrchestrationState: A new state with the current task marked as completed.\n        \"\"\"\n        tool_data = state[\"tool_data\"].copy()\n        if tools.delegate_tasks.name in tool_data:\n            task_list = tool_data[tools.delegate_tasks.name][\"task_list\"]\n            for task in task_list:\n                # Mark first unfinished task as completed\n                if not task.get(\"is_finished\", False):\n                    task[\"is_finished\"] = True\n                    task[\"response\"] = response\n                    break\n\n        return {**state, \"tool_data\": tool_data}\n\n    @classmethod\n    def task_to_instruction(cls, task: dict, state: OrchestrationState) -&gt; str:\n        task_list_data = state[\"tool_data\"][tools.delegate_tasks.name]\n        general_objective = task_list_data[\"general_objective\"]\n\n        completed_tasks = OrchestratorAgent.get_completed_tasks(state)\n        completed_tasks_info = \"\\n\".join([f\"- Completed: {t['objective']}\\n  {t['details']}\" for t in completed_tasks])\n\n        # Get any image for multi-modal llm\n        images = list(filter(lambda res: res.startswith(\"img::\"), task_list_data[\"resources\"]))\n        other_resources = list(filter(lambda res: not res.startswith(\"img::\"), task_list_data[\"resources\"]))\n        images_instruction = \"\"\n        resources_instruction = \"\"\n\n        if images:\n            images_instruction += f\"\\n*Reference images:* {''.join(images)}\"\n        if other_resources:\n            resources_instruction += f\"\\n*Other resources:* {''.join(other_resources)}\"\n\n        return f\"\"\"\\\nYou are requested to solve a specific task related to the objective: {general_objective}.\n\nThese tasks were already completed:\n\n*Context (completed tasks):*\n{completed_tasks_info}\n\n\n*You must execute/complete only the following task:*\n\nObjective: {task[\"objective\"]}\nDetails: {task[\"details\"]}\nRestrictions: {task.get(\"restrictions\", \"No specific restrictions.\")}\nExpected Outcome: {task.get(\"outcome\", \"No specific outcome defined.\")}\n\n*Read all files mentioned in tasks above* for context, then analyze if need to load any else to complete the task.\n\n{images_instruction}\n{resources_instruction}\n\nWrite you answer step by step, using a &lt;thinking&gt; block for analysis your thoughts before giving a response to me using &lt;step&gt; and edit files using &lt;source&gt; blocks.\n\"\"\"\n\n    @classmethod\n    def is_task_list_empty(cls, state: OrchestrationState):\n        \"\"\"\n        Check if the task list is empty in the state.\n\n        Args:\n            state (OrchestrationState): The current state containing tasks.\n\n        Returns:\n            bool: True if the task list is empty, False otherwise.\n        \"\"\"\n        if (\n            \"tool_data\" not in state\n            or not state[\"tool_data\"]\n            or tools.delegate_tasks.name not in state[\"tool_data\"]\n            or not state[\"tool_data\"][tools.delegate_tasks.name]\n        ):\n            return True\n\n        task_list = state[\"tool_data\"][tools.delegate_tasks.name][\"task_list\"]\n        return not task_list\n\n    @classmethod\n    def is_task_list_complete(cls, state: OrchestrationState):\n        \"\"\"\n        Check if the task list is complete in the state.\n\n        Args:\n            state (OrchestrationState): The current state containing tasks.\n\n        Returns:\n            bool: True if the task list is complete, False otherwise.\n        \"\"\"\n\n        task_list = state[\"tool_data\"][tools.delegate_tasks.name][\"task_list\"]\n        return all(task.get(\"is_finished\", False) for task in task_list)\n\n    @classmethod\n    def was_task_validation_tool_used(cls, state: OrchestrationState) -&gt; bool:\n        \"\"\"\n        Check if the validation tool was used in the last message.\n\n        Args:\n            state (OrchestrationState): The current state containing messages.\n\n        Returns:\n            bool: True if the validation tool was used, False otherwise.\n        \"\"\"\n\n        if \"tool_data\" not in state or not state[\"tool_data\"]:\n            return False\n\n        return tools.is_task_completed.name in state[\"tool_data\"]\n</code></pre>"},{"location":"api/agents/#pluscoder.agents.orchestrator.OrchestratorAgent.get_completed_tasks","title":"get_completed_tasks  <code>classmethod</code>","text":"<pre><code>get_completed_tasks(state: OrchestrationState) -&gt; List[dict]\n</code></pre> <p>Get the list of completed tasks from the state.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>OrchestrationState</code> <p>The current state containing tasks.</p> required <p>Returns:</p> Type Description <code>List[dict]</code> <p>List[dict]: A list of completed tasks with their results.</p> Source code in <code>pluscoder/agents/orchestrator.py</code> <pre><code>@classmethod\ndef get_completed_tasks(cls, state: OrchestrationState) -&gt; List[dict]:\n    \"\"\"\n    Get the list of completed tasks from the state.\n\n    Args:\n        state (OrchestrationState): The current state containing tasks.\n\n    Returns:\n        List[dict]: A list of completed tasks with their results.\n    \"\"\"\n    if (\n        \"tool_data\" not in state\n        or not state[\"tool_data\"]\n        or tools.delegate_tasks.name not in state[\"tool_data\"]\n        or not state[\"tool_data\"][tools.delegate_tasks.name]\n        or \"task_list\" not in state[\"tool_data\"][tools.delegate_tasks.name]\n    ):\n        return []\n\n    task_list = state[\"tool_data\"][tools.delegate_tasks.name][\"task_list\"]\n    return [task for task in task_list if task.get(\"is_finished\", False)]\n</code></pre>"},{"location":"api/agents/#pluscoder.agents.orchestrator.OrchestratorAgent.get_current_task","title":"get_current_task  <code>classmethod</code>","text":"<pre><code>get_current_task(state: OrchestrationState)\n</code></pre> <p>Get the first task that is not finished from the state.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>OrchestrationState</code> <p>The current state containing tasks.</p> required <p>Returns:</p> Name Type Description <code>Task</code> <p>The first unfinished task, or None if all tasks are finished or no tasks exist.</p> Source code in <code>pluscoder/agents/orchestrator.py</code> <pre><code>@classmethod\ndef get_current_task(cls, state: OrchestrationState):\n    \"\"\"\n    Get the first task that is not finished from the state.\n\n    Args:\n        state (OrchestrationState): The current state containing tasks.\n\n    Returns:\n        Task: The first unfinished task, or None if all tasks are finished or no tasks exist.\n    \"\"\"\n    if (\n        \"tool_data\" not in state\n        or not state[\"tool_data\"]\n        or tools.delegate_tasks.name not in state[\"tool_data\"]\n        or not state[\"tool_data\"][tools.delegate_tasks.name]\n        or \"task_list\" not in state[\"tool_data\"][tools.delegate_tasks.name]\n    ):\n        return None\n\n    task_list = state[\"tool_data\"][tools.delegate_tasks.name][\"task_list\"]\n    return next((task for task in task_list if not task.get(\"is_finished\", False)), None)\n</code></pre>"},{"location":"api/agents/#pluscoder.agents.orchestrator.OrchestratorAgent.get_task_list","title":"get_task_list  <code>classmethod</code>","text":"<pre><code>get_task_list(state: OrchestrationState) -&gt; List[dict]\n</code></pre> <p>Get the task list from the state.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>OrchestrationState</code> <p>The current state containing tasks.</p> required <p>Returns:</p> Type Description <code>List[dict]</code> <p>List[dict]: The task list.</p> Source code in <code>pluscoder/agents/orchestrator.py</code> <pre><code>@classmethod\ndef get_task_list(cls, state: OrchestrationState) -&gt; List[dict]:\n    \"\"\"\n    Get the task list from the state.\n\n    Args:\n        state (OrchestrationState): The current state containing tasks.\n\n    Returns:\n        List[dict]: The task list.\n    \"\"\"\n    if \"tool_data\" not in state or not state[\"tool_data\"] or tools.delegate_tasks.name not in state[\"tool_data\"]:\n        return []\n\n    return state[\"tool_data\"][tools.delegate_tasks.name][\"task_list\"]\n</code></pre>"},{"location":"api/agents/#pluscoder.agents.orchestrator.OrchestratorAgent.get_tool_choice","title":"get_tool_choice","text":"<pre><code>get_tool_choice(state: OrchestrationState) -&gt; str\n</code></pre> <p>Chooses a the tool to use when calling the llm</p> Source code in <code>pluscoder/agents/orchestrator.py</code> <pre><code>def get_tool_choice(self, state: OrchestrationState) -&gt; str:\n    \"\"\"Chooses a the tool to use when calling the llm\"\"\"\n    if state[\"status\"] == \"delegating\":\n        return tools.is_task_completed.name\n    return \"auto\"\n</code></pre>"},{"location":"api/agents/#pluscoder.agents.orchestrator.OrchestratorAgent.is_agent_response","title":"is_agent_response  <code>classmethod</code>","text":"<pre><code>is_agent_response(state: OrchestrationState) -&gt; bool\n</code></pre> <p>Verify if the last message in the state is from an agent.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>OrchestrationState</code> <p>The current state containing messages.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the last message is from an agent, False otherwise.</p> Source code in <code>pluscoder/agents/orchestrator.py</code> <pre><code>@classmethod\ndef is_agent_response(cls, state: OrchestrationState) -&gt; bool:\n    \"\"\"\n    Verify if the last message in the state is from an agent.\n\n    Args:\n        state (OrchestrationState): The current state containing messages.\n\n    Returns:\n        bool: True if the last message is from an agent, False otherwise.\n    \"\"\"\n    if not state[\"messages\"]:\n        return False\n\n    last_message = state[\"messages\"][-1]\n    # Assuming agent messages are not instances of HumanMessage\n    return not isinstance(last_message, HumanMessage)\n</code></pre>"},{"location":"api/agents/#pluscoder.agents.orchestrator.OrchestratorAgent.is_task_list_complete","title":"is_task_list_complete  <code>classmethod</code>","text":"<pre><code>is_task_list_complete(state: OrchestrationState)\n</code></pre> <p>Check if the task list is complete in the state.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>OrchestrationState</code> <p>The current state containing tasks.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <p>True if the task list is complete, False otherwise.</p> Source code in <code>pluscoder/agents/orchestrator.py</code> <pre><code>@classmethod\ndef is_task_list_complete(cls, state: OrchestrationState):\n    \"\"\"\n    Check if the task list is complete in the state.\n\n    Args:\n        state (OrchestrationState): The current state containing tasks.\n\n    Returns:\n        bool: True if the task list is complete, False otherwise.\n    \"\"\"\n\n    task_list = state[\"tool_data\"][tools.delegate_tasks.name][\"task_list\"]\n    return all(task.get(\"is_finished\", False) for task in task_list)\n</code></pre>"},{"location":"api/agents/#pluscoder.agents.orchestrator.OrchestratorAgent.is_task_list_empty","title":"is_task_list_empty  <code>classmethod</code>","text":"<pre><code>is_task_list_empty(state: OrchestrationState)\n</code></pre> <p>Check if the task list is empty in the state.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>OrchestrationState</code> <p>The current state containing tasks.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <p>True if the task list is empty, False otherwise.</p> Source code in <code>pluscoder/agents/orchestrator.py</code> <pre><code>@classmethod\ndef is_task_list_empty(cls, state: OrchestrationState):\n    \"\"\"\n    Check if the task list is empty in the state.\n\n    Args:\n        state (OrchestrationState): The current state containing tasks.\n\n    Returns:\n        bool: True if the task list is empty, False otherwise.\n    \"\"\"\n    if (\n        \"tool_data\" not in state\n        or not state[\"tool_data\"]\n        or tools.delegate_tasks.name not in state[\"tool_data\"]\n        or not state[\"tool_data\"][tools.delegate_tasks.name]\n    ):\n        return True\n\n    task_list = state[\"tool_data\"][tools.delegate_tasks.name][\"task_list\"]\n    return not task_list\n</code></pre>"},{"location":"api/agents/#pluscoder.agents.orchestrator.OrchestratorAgent.mark_current_task_as_completed","title":"mark_current_task_as_completed  <code>classmethod</code>","text":"<pre><code>mark_current_task_as_completed(\n    state: OrchestrationState, response: str\n) -&gt; OrchestrationState\n</code></pre> <p>Mark the current task as completed and return a new state. Adds the llm response to understand in which message the response was marked as completed.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>OrchestrationState</code> <p>The current state.</p> required <code>response</code> <code>str</code> <p>The response of the llm that completed the task.</p> required <p>Returns:</p> Name Type Description <code>OrchestrationState</code> <code>OrchestrationState</code> <p>A new state with the current task marked as completed.</p> Source code in <code>pluscoder/agents/orchestrator.py</code> <pre><code>@classmethod\ndef mark_current_task_as_completed(cls, state: OrchestrationState, response: str) -&gt; OrchestrationState:\n    \"\"\"\n    Mark the current task as completed and return a new state.\n    Adds the llm response to understand in which message the response was marked as completed.\n\n    Args:\n        state (OrchestrationState): The current state.\n        response (str): The response of the llm that completed the task.\n\n    Returns:\n        OrchestrationState: A new state with the current task marked as completed.\n    \"\"\"\n    tool_data = state[\"tool_data\"].copy()\n    if tools.delegate_tasks.name in tool_data:\n        task_list = tool_data[tools.delegate_tasks.name][\"task_list\"]\n        for task in task_list:\n            # Mark first unfinished task as completed\n            if not task.get(\"is_finished\", False):\n                task[\"is_finished\"] = True\n                task[\"response\"] = response\n                break\n\n    return {**state, \"tool_data\": tool_data}\n</code></pre>"},{"location":"api/agents/#pluscoder.agents.orchestrator.OrchestratorAgent.remove_task_list_data","title":"remove_task_list_data  <code>classmethod</code>","text":"<pre><code>remove_task_list_data(state: OrchestrationState) -&gt; OrchestrationState\n</code></pre> <p>Remove the task list data from the state.</p> Source code in <code>pluscoder/agents/orchestrator.py</code> <pre><code>@classmethod\ndef remove_task_list_data(cls, state: OrchestrationState) -&gt; OrchestrationState:\n    \"\"\"Remove the task list data from the state.\"\"\"\n    return {\n        **state,\n        \"tool_data\": {**state[\"tool_data\"], tools.delegate_tasks.name: None},\n    }\n</code></pre>"},{"location":"api/agents/#pluscoder.agents.orchestrator.OrchestratorAgent.validate_current_task_completed","title":"validate_current_task_completed  <code>classmethod</code>","text":"<pre><code>validate_current_task_completed(state: OrchestrationState) -&gt; bool\n</code></pre> <p>Check if the current task is completed based on the state last tool used.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>OrchestrationState</code> <p>The current state containing task completion status.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the current task is completed, False otherwise.</p> Source code in <code>pluscoder/agents/orchestrator.py</code> <pre><code>@classmethod\ndef validate_current_task_completed(cls, state: OrchestrationState) -&gt; bool:\n    \"\"\"\n    Check if the current task is completed based on the state last tool used.\n\n    Args:\n        state (OrchestrationState): The current state containing task completion status.\n\n    Returns:\n        bool: True if the current task is completed, False otherwise.\n    \"\"\"\n    if \"tool_data\" not in state or not state[\"tool_data\"]:\n        return False\n\n    if tools.is_task_completed.name not in state[\"tool_data\"]:\n        return False\n\n    return state[\"tool_data\"][tools.is_task_completed.name][\"completed\"]\n</code></pre>"},{"location":"api/agents/#pluscoder.agents.orchestrator.OrchestratorAgent.was_task_validation_tool_used","title":"was_task_validation_tool_used  <code>classmethod</code>","text":"<pre><code>was_task_validation_tool_used(state: OrchestrationState) -&gt; bool\n</code></pre> <p>Check if the validation tool was used in the last message.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>OrchestrationState</code> <p>The current state containing messages.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the validation tool was used, False otherwise.</p> Source code in <code>pluscoder/agents/orchestrator.py</code> <pre><code>@classmethod\ndef was_task_validation_tool_used(cls, state: OrchestrationState) -&gt; bool:\n    \"\"\"\n    Check if the validation tool was used in the last message.\n\n    Args:\n        state (OrchestrationState): The current state containing messages.\n\n    Returns:\n        bool: True if the validation tool was used, False otherwise.\n    \"\"\"\n\n    if \"tool_data\" not in state or not state[\"tool_data\"]:\n        return False\n\n    return tools.is_task_completed.name in state[\"tool_data\"]\n</code></pre>"},{"location":"api/config/","title":"Configuration API Reference","text":""},{"location":"api/config/#configuration-utilities","title":"Configuration Utilities","text":""},{"location":"api/config/#pluscoder.config","title":"pluscoder.config","text":""},{"location":"api/tools/","title":"Tools API Reference","text":""},{"location":"api/tools/#core-tools","title":"Core Tools","text":""},{"location":"api/tools/#pluscoder.tools","title":"pluscoder.tools","text":""},{"location":"api/tools/#pluscoder.tools.ask_confirmation","title":"ask_confirmation","text":"<pre><code>ask_confirmation(\n    message: Annotated[str, \"The message to display for confirmation.\"]\n) -&gt; str\n</code></pre> <p>Ask for user confirmation with a custom message.</p> Source code in <code>pluscoder/tools.py</code> <pre><code>@tool\ndef ask_confirmation(\n    message: Annotated[str, \"The message to display for confirmation.\"],\n) -&gt; str:\n    \"\"\"Ask for user confirmation with a custom message.\"\"\"\n    response = io.console.input(f\"[bold green]{message} (y/n): [/bold green]\")\n    if response.lower() == \"y\":\n        return \"Confirmed\"\n    return response\n</code></pre>"},{"location":"api/tools/#pluscoder.tools.convert_to_raw_url","title":"convert_to_raw_url","text":"<pre><code>convert_to_raw_url(url: str) -&gt; str\n</code></pre> <p>Convert repository URL to raw file URL.</p> Source code in <code>pluscoder/tools.py</code> <pre><code>def convert_to_raw_url(url: str) -&gt; str:\n    \"\"\"Convert repository URL to raw file URL.\"\"\"\n    parsed_url = urlparse(url)\n    path_parts = parsed_url.path.split(\"/\")\n\n    if parsed_url.netloc == \"github.com\":\n        if len(path_parts) &gt;= 5 and path_parts[3] == \"blob\":\n            return f\"https://raw.githubusercontent.com/{path_parts[1]}/{path_parts[2]}/{'/'.join(path_parts[4:])}\"\n    elif parsed_url.netloc == \"gitlab.com\" and \"/-/blob/\" in parsed_url.path:\n        return url.replace(\"/-/blob/\", \"/-/raw/\", 1)\n    # elif parsed_url.netloc == \"bitbucket.org\":\n    #     if len(path_parts) &gt;= 5 and path_parts[3] == \"src\":\n    #         return f\"https://bitbucket.org/{path_parts[1]}/{path_parts[2]}/raw/{'/'.join(path_parts[4:])}\"\n    # elif (\n    #     parsed_url.netloc == \"dev.azure.com\"\n    #     and len(path_parts) &gt;= 7\n    #     and path_parts[5] == \"blob\"\n    # ):\n    #     org, project = path_parts[1], path_parts[2]\n    #     repo = path_parts[4]\n    #     branch_and_file = \"/\".join(path_parts[6:])\n    #     return f\"https://dev.azure.com/{org}/{project}/_apis/git/repositories/{repo}/items?path=/{branch_and_file}&amp;api-version=6.0\"\n\n    return url  # Return original URL if not a recognized repository link\n</code></pre>"},{"location":"api/tools/#pluscoder.tools.delegate_tasks","title":"delegate_tasks","text":"<pre><code>delegate_tasks(\n    general_objective: Annotated[str, \"The general objective for all tasks.\"],\n    task_list: Annotated[\n        List[AgentTask],\n        \"List of tasks, each task being a dictionary with 'objective', 'details', 'agent', 'is_finished', 'restrictions', and 'outcome' keys.\",\n    ],\n    resources: Annotated[\n        List[str],\n        \"List of resources specified by the user external to the repository. (url/links/local files)\",\n    ],\n) -&gt; Dict[str, List[AgentTask]]\n</code></pre> <p>Delegates tasks to other agents to execute/complete them. Each task in the task_list must be a dict with 6 values: (objective, details, agent, is_finished, restrictions, outcome). The 'agent' value must be one of: \"developer\". The 'is_finished' value is a boolean indicating whether the task has been completed. The 'restrictions' value is a string describing any limitations or constraints for the task. The 'outcome' value is a string describing the expected result of the task. The 'resources' value contains the list of resources the same exact format the user passed it. Including 'img::' if present.</p> Source code in <code>pluscoder/tools.py</code> <pre><code>@tool\ndef delegate_tasks(\n    general_objective: Annotated[str, \"The general objective for all tasks.\"],\n    task_list: Annotated[\n        List[AgentTask],\n        \"List of tasks, each task being a dictionary with 'objective', 'details', 'agent', 'is_finished', 'restrictions', and 'outcome' keys.\",\n    ],\n    resources: Annotated[\n        List[str],\n        \"List of resources specified by the user external to the repository. (url/links/local files)\",\n    ],\n) -&gt; Dict[str, List[AgentTask]]:\n    \"\"\"\n    Delegates tasks to other agents to execute/complete them. Each task in the task_list must be a dict with 6 values: (objective, details, agent, is_finished, restrictions, outcome).\n    The 'agent' value must be one of: \"developer\".\n    The 'is_finished' value is a boolean indicating whether the task has been completed.\n    The 'restrictions' value is a string describing any limitations or constraints for the task.\n    The 'outcome' value is a string describing the expected result of the task.\n    The 'resources' value contains the list of resources the same exact format the user passed it. Including 'img::' if present.\n    \"\"\"\n    return f\"Task '{general_objective}' about to be delegated. \\n\\n{task_list}\"\n</code></pre>"},{"location":"api/tools/#pluscoder.tools.extract_files","title":"extract_files","text":"<pre><code>extract_files(\n    mentioned_files: Annotated[str, \"Entire list of filenames of file mentions.\"]\n) -&gt; Dict[str, List[Dict[str, str]]]\n</code></pre> <p>Detect and extract all files mentioned with their full paths.</p> Source code in <code>pluscoder/tools.py</code> <pre><code>@tool\ndef extract_files(\n    mentioned_files: Annotated[str, \"Entire list of filenames of file mentions.\"],\n) -&gt; Dict[str, List[Dict[str, str]]]:\n    \"\"\"\n    Detect and extract all files mentioned with their full paths.\n    \"\"\"\n    io.print(mentioned_files)\n    return mentioned_files\n</code></pre>"},{"location":"api/tools/#pluscoder.tools.file_detection_with_confirmation","title":"file_detection_with_confirmation","text":"<pre><code>file_detection_with_confirmation(\n    file_path: Annotated[str, \"The path to the file you want to update.\"],\n    content: Annotated[\n        str, \"The entire content including file blocks to be processed.\"\n    ],\n    confirmation: Annotated[str, \"Confirmation status ('YES' or any other value).\"],\n) -&gt; str\n</code></pre> <p>Extract file blocks from content and update the file if confirmed.</p> Source code in <code>pluscoder/tools.py</code> <pre><code>@tool\ndef file_detection_with_confirmation(\n    file_path: Annotated[str, \"The path to the file you want to update.\"],\n    content: Annotated[str, \"The entire content including file blocks to be processed.\"],\n    confirmation: Annotated[str, \"Confirmation status ('YES' or any other value).\"],\n) -&gt; str:\n    \"\"\"\n    Extract file blocks from content and update the file if confirmed.\n    \"\"\"\n    file_blocks = re.findall(r\"(\\S+)\\n```[\\w-]*\\n(.*?)\\n```\", content, re.DOTALL)\n\n    if not file_blocks:\n        return \"No file blocks detected in the content.\"\n\n    for file_name, file_content in file_blocks:\n        if file_name == file_path:\n            if confirmation == \"YES\":\n                return update_file.run({\"file_path\": file_path, \"content\": file_content.strip()})\n            return f\"Update for {file_path} was not confirmed.\"\n\n    return f\"No matching file block found for {file_path}.\"\n</code></pre>"},{"location":"api/tools/#pluscoder.tools.is_task_completed","title":"is_task_completed","text":"<pre><code>is_task_completed(\n    completed: Annotated[bool, \"Boolean indicating whether the task is completed.\"],\n    feedback: Annotated[str, \"Feedback from the agent regarding the task completion.\"],\n) -&gt; Dict[str, bool]\n</code></pre> <p>Extract a boolean indicating whether specified task was completed successfully or not</p> Source code in <code>pluscoder/tools.py</code> <pre><code>@tool\ndef is_task_completed(\n    completed: Annotated[bool, \"Boolean indicating whether the task is completed.\"],\n    feedback: Annotated[str, \"Feedback from the agent regarding the task completion.\"],\n) -&gt; Dict[str, bool]:\n    \"\"\"\n    Extract a boolean indicating whether specified task was completed successfully or not\n    \"\"\"\n    return {\"completed\": completed, \"feedback\": feedback}\n</code></pre>"},{"location":"api/tools/#pluscoder.tools.move_files","title":"move_files","text":"<pre><code>move_files(\n    file_paths: Annotated[\n        List[Dict[str, str]],\n        \"List of dictionaries, each containing 'from' and 'to' keys for the source and destination paths of each file to be moved.\",\n    ]\n) -&gt; str\n</code></pre> <p>Move multiple files from their current locations to new locations.</p> Source code in <code>pluscoder/tools.py</code> <pre><code>@tool\ndef move_files(\n    file_paths: Annotated[\n        List[Dict[str, str]],\n        \"List of dictionaries, each containing 'from' and 'to' keys for the source and destination paths of each file to be moved.\",\n    ],\n) -&gt; str:\n    \"\"\"Move multiple files from their current locations to new locations.\"\"\"\n    results = []\n    for file_path in file_paths:\n        from_path = file_path[\"from\"]\n        to_path = file_path[\"to\"]\n        try:\n            shutil.move(from_path, to_path)\n            results.append(f\"Successfully moved {from_path} to {to_path}\")\n        except Exception as e:\n            results.append(f\"Failed to move {from_path} to {to_path}: {e!s}\")\n\n    success_count = sum(1 for result in results if result.startswith(\"Successfully\"))\n    failure_count = len(results) - success_count\n\n    summary = f\"Moved {success_count} file(s) successfully. {failure_count} file(s) failed to move.\"\n    details = \"\\n\".join(results)\n\n    return f\"{summary}\\n\\nDetails:\\n{details}\"\n</code></pre>"},{"location":"api/tools/#pluscoder.tools.query_repository","title":"query_repository","text":"<pre><code>query_repository(\n    query: Annotated[\n        str,\n        \"Natural language query with keywords to find relevant code, content and files in the repository.\",\n    ]\n) -&gt; str\n</code></pre> <p>Search key file snippets and filenames in the repository for better understanding and analysis given a new user request.</p> Source code in <code>pluscoder/tools.py</code> <pre><code>@tool\ndef query_repository(\n    query: Annotated[\n        str, \"Natural language query with keywords to find relevant code, content and files in the repository.\"\n    ],\n) -&gt; str:\n    \"\"\"\n    Search key file snippets and filenames in the repository for better understanding and analysis given a new user request.\n    \"\"\"\n    try:\n        from pluscoder.search.engine import SearchEngine\n\n        engine = SearchEngine.get_instance()\n        results = engine.search(query, top_k=5)\n\n        if not results:\n            return \"No matching results found in repository. Just read key files of the repository for better understanding and analysis.\"\n\n        output = f\"Found {len(results)} possible relevant results for query '{query}':\\n\\n\"\n\n        for result in results:\n            file_path = result.chunk.file_metadata.file_path\n            relevance = f\"{result.score:.2%}\"\n            lines = f\"lines {result.start_line}-{result.end_line}\"\n            snippet = result.chunk.content.strip()\n\n            output += f\"\ud83d\udcc4 {file_path} ({lines}) - Relevance: {relevance}\\n\"\n            output += f\"Snippet:\\n{snippet}\\n\\n\"\n\n        output += \"Given these results analyze which key files to read and if is necessary to perform another search query for handling the user request.\"\n\n        return output\n\n    except Exception:\n        io.print(traceback.format_exc(), style=\"bold red\")\n        return \"Search engine is not available. Just read key files of the repository for better understanding and analysis.\"\n</code></pre>"},{"location":"api/tools/#pluscoder.tools.read_file_from_url","title":"read_file_from_url","text":"<pre><code>read_file_from_url(url: Annotated[str, 'The URL of the file to read.']) -&gt; str\n</code></pre> <p>Reads the content of a file given its URL or repository link.</p> Source code in <code>pluscoder/tools.py</code> <pre><code>@tool\ndef read_file_from_url(url: Annotated[str, \"The URL of the file to read.\"]) -&gt; str:\n    \"\"\"Reads the content of a file given its URL or repository link.\"\"\"\n    try:\n        raw_url = convert_to_raw_url(url)\n        response = requests.get(raw_url)\n        response.raise_for_status()\n        content = response.text\n        return f\"Here is the content of the file:\\n\\n{content}\"\n    except requests.RequestException as e:\n        return f\"Error downloading file: {e!s}. It is possible that the given link is not a valid file or url\"\n</code></pre>"},{"location":"api/tools/#pluscoder.tools.read_files","title":"read_files","text":"<pre><code>read_files(\n    file_paths: Annotated[List[str], \"The paths to the files you want to read.\"]\n) -&gt; str\n</code></pre> <p>Read the contents of multiple files at once</p> Source code in <code>pluscoder/tools.py</code> <pre><code>@tool\ndef read_files(\n    file_paths: Annotated[List[str], \"The paths to the files you want to read.\"],\n) -&gt; str:\n    \"\"\"Read the contents of multiple files at once\"\"\"\n    result = \"\"\n    errors = []\n    loaded_files = []\n\n    for file_path in file_paths:\n        try:\n            result += get_formatted_file_content(file_path)\n            loaded_files.append(file_path)\n        except Exception as e:\n            errors.append(f\"Error reading file {file_path}. Maybe the path is wrong or the file never existed: {e!s}\")\n\n    if errors:\n        result += \"\\n\\nErrors:\\n\" + \"\\n\".join(errors)\n\n    io.event(f\"&gt; Added files: {', '.join(loaded_files)}\")\n\n    return \"Here are the files content:\\n\\n\" + result.strip()\n</code></pre>"},{"location":"api/tools/#pluscoder.tools.select_agent","title":"select_agent","text":"<pre><code>select_agent(\n    agent_node: Annotated[\n        Literal[\"domain_stakeholder\", \"planning\", \"developer\", \"domain_expert\"],\n        \"The type of agent to select for the next task.\",\n    ],\n    task: Annotated[str, \"The specific task to be handled by the selected agent.\"],\n) -&gt; str\n</code></pre> <p>Select the best suitable and appropriate agent for handling the specific task.</p> Source code in <code>pluscoder/tools.py</code> <pre><code>@tool\ndef select_agent(\n    agent_node: Annotated[\n        Literal[\"domain_stakeholder\", \"planning\", \"developer\", \"domain_expert\"],\n        \"The type of agent to select for the next task.\",\n    ],\n    task: Annotated[str, \"The specific task to be handled by the selected agent.\"],\n) -&gt; str:\n    \"\"\"\n    Select the best suitable and appropriate agent for handling the specific task.\n    \"\"\"\n    # This tool doesn't need real logic\n    # LLM response fills this tool with all values we define here for future use\n    return f\"{agent_node}:{task}\"\n</code></pre>"},{"location":"api/tools/#pluscoder.tools.update_file","title":"update_file","text":"<pre><code>update_file(\n    file_path: Annotated[str, \"The path to the file you want to update/create.\"],\n    content: Annotated[str, \"New entire content to put in the file.\"],\n) -&gt; str\n</code></pre> <p>Replace the entire content of an existing file or create a new file.</p> Source code in <code>pluscoder/tools.py</code> <pre><code>@tool\ndef update_file(\n    file_path: Annotated[str, \"The path to the file you want to update/create.\"],\n    content: Annotated[str, \"New entire content to put in the file.\"],\n) -&gt; str:\n    \"\"\"Replace the entire content of an existing file or create a new file.\"\"\"\n    try:\n        with open(file_path, \"w\") as file:\n            file.write(content)\n        return f\"File updated successfully at {file_path}\"\n    except Exception as e:\n        return f\"Error updating file: {e!s}\"\n</code></pre>"},{"location":"cloud/","title":"Cloud and Automation Guide","text":""},{"location":"cloud/#overview","title":"Overview","text":"<p>Learn about advanced PlusCoder features for cloud deployment and workflow automation.</p>"},{"location":"cloud/#sections","title":"Sections","text":"<ul> <li>Non-Interactive Mode</li> <li>Workflow Automation</li> </ul>"},{"location":"cloud/non_interactive_mode/","title":"Non-Interactive Mode","text":""},{"location":"cloud/workflow_automation/","title":"Workflow Automation","text":""},{"location":"documentation/agents/","title":"Agents","text":"<p>PlusCoder core system relies on agents to perform tasks and provide assistance to the user.</p>"},{"location":"documentation/agents/#features","title":"Features","text":"<p>PlusCoder agents have the following features:</p> Feature Description Example instruction <code>Filesystem interaction</code> Agents can create/edit files on the repository workspace. <code>Read core files and explain me what is this repository about</code> <code>File downloading</code> Agents can download files from external sources given their raw URLs when instructed to do. <code>Read https://github.com/granade-io/pluscoder/blob/develop/CODING_GUIDELINES.md and apply them to utils.py</code> <code>Multi-modal support</code> Agents can read images passed as input by the user using <code>img::&lt;img_url&gt;</code> or pasting an image with Ctrl+V  during the conversation. <code>I'd like you to code a navbar.js identical to this one at img::https://user-images.githubusercontent.com/25878302/212479928-553c2d37-793b-4bcd-ac53-352f26337955.jpg</code> <code>Test and Lint support</code> After editions, agents will execute tests and linting commands in the repository workspace and try recover from errors. See config here. <code>update validate_email to handle validation using a regex</code> <p>Multi-modal support</p> <p>Not all models support multi-modal inputs. And we rely en OpenAI's API scheme to provide this feature. Providers like OpenAI and Anthropic support multi-modal inputs.</p> <p>Recover from errors</p> <p>Agents will try to recover from errors at most 3 times to avoid infinite loops and cost overruns. We recommend to specify just key linting and testing commands in the configuration to avoid unnecessary errors.</p>"},{"location":"documentation/agents/#predefined-agents","title":"Predefined Agents","text":"<p>PlusCoder comes with a set of predefined agents that can be used in your conversations or automated runs.</p> <ul> <li><code>Orchestrator</code>: Agent that helps you define a task list based plan. It also run the tasks delegating them to other agents until each task is completed.</li> </ul> <p>Using Orchestrator</p> <p>When using the Orchestrator agent, be clear with your intentions. Tell the agent to \"create a plan\" and to \"delegate it\" to other agents after reviewing it.</p> <p>Example:</p> CLIIn-Chat <pre><code>pluscoder \\\n--default_agent orchestrator \\\n--auto_confirm yes \\\n--user_input \"I need to refactor main.py into utils.py and config.py; Create a plan with a task to refactor and a second task to add unit tests for new files. Delegate it immediately\" \n</code></pre> <pre><code>&gt; You: I need to refactor main.py into utils.py and config.py; Create a plan with a task to refactor and a second task to add unit tests for new files. Show me the plan.\n&gt; Orchestrator: &lt;plan output&gt;\n&gt; You: Delegate it\n</code></pre> <ul> <li><code>Developer</code>: Agent to perform general development tasks through code generation.</li> </ul> <p>Using Developer</p> <p>Developer can read/edit files by itself. You can ask it to generate code, fix errors, or create new files. If you don't want Developer agent to edit files, tell it explicitly.</p> <ul> <li><code>Domain Stakeholder</code>: Agent useful for discussing project details, design decisions, business requirements, roadmap, etc. It will ask you key questions to help you achieve your goals.</li> </ul> <p>Using Domain Stakeholder</p> <p>Stakeholder can read/edit files the same way as Developer. Talk with it when some inspiration is needed or when you are unsure about how to proceed.</p>"},{"location":"documentation/agents/#custom-agents","title":"Custom Agents","text":"<p>Custom agents can be defined using <code>custom_agents</code> configuration in PlusCoder.</p> <p>Agents perform better when their instruction are specific to the problem domain we are working on.</p>"},{"location":"documentation/agents/#use-cases","title":"Use Cases","text":"<p>You can use custom agents for:</p> <ol> <li>Having custom knowledge and instructions to perform specific tasks:<ol> <li>For example, a <code>CodeReviewer</code> agent can be created to review code changes and provide feedback on code quality, best practices, and potential issues.</li> <li>A <code>DocstringGenerator</code> agent can be created to generate docstrings for specified files following a specific format or guidelines.</li> <li>A <code>Brainstormer</code> agent can be created to propose ideas for implementation without editing the codebase.</li> <li>A <code>CodeStyleEnforcer</code> agent can be created to enforce code style guidelines in the codebase.</li> </ol> </li> <li>Having experts in different domains:<ol> <li>For example, a <code>SecurityExpert</code> agent can be created to review security vulnerabilities in the codebase.</li> <li>A <code>VueJsExpert</code> agent can be created to provide guidance on Vue.js specific problems.</li> <li><code>MyCompanyExpert</code> agent can be created to provide expert advice on specific aspects of your company's business.</li> </ol> </li> <li>Having custom tools and integrations:<ol> <li>For example, a <code>JiraIntegration</code> agent can be created to interact with Jira API to create issues, assign tasks, or update issues.</li> <li>A <code>SlackIntegration</code> agent can be created to interact with Slack API to send messages, create channels, or update messages.</li> <li>A <code>GithubIssuesIntegration</code> agent can be created to interact with Github API to create issues, assign tasks, or update issues.</li> </ol> </li> </ol>"},{"location":"documentation/agents/#related-docs","title":"Related Docs","text":"<ul> <li>Configuration</li> <li>CLI Usage</li> </ul>"},{"location":"documentation/automation/","title":"Automation","text":"<p>Automation can be reached in two ways: out-of-the-box using the CLI and through custom python scripts.</p>"},{"location":"documentation/automation/#cli","title":"CLI","text":"<p>PlusCoder CLI handles most core functionalities automatically, so you can just give an instruction or task list to agents to work in the repository without any additional code or configuration.</p> <pre><code>pluscoder --user_input \"List all open issues in the 'pluscoder/pluscoder' repository\" --default_agent developer --auto_confirm yes\n</code></pre> <p>Tip</p> <p>The <code>--auto_confirm</code> flag is used to skip the confirmation steps allowing agents to run freely.</p> <p>Under the hood:</p> <ul> <li>CLI reads configuration from different sources</li> <li>Repository is indexed using embedding model if its defined</li> <li>Detects task list and parses it to run Orchestrator Agent with orchestrated workflow</li> </ul>"},{"location":"documentation/automation/#basic-examples","title":"Basic examples","text":""},{"location":"documentation/automation/#basic-coding-instruction","title":"Basic coding instruction","text":"<pre><code>pluscoder --user_input \"Write unit tests for api/endpoints.py endpoints\" --default_agent developer --auto_confirm yes\n</code></pre>"},{"location":"documentation/automation/#instruction-supported-with-remote-guidelines","title":"Instruction supported with remote guidelines","text":"<pre><code>pluscoder --user_input \"Read the 'Code Style Guide' file at https://github.com/pluscoder/pluscoder/blob/main/docs/CodeStyleGuide.md and apply it to the codebase\" --default_agent developer --auto_confirm yes\n</code></pre>"},{"location":"documentation/automation/#handling-multiple-repositories","title":"Handling multiple repositories","text":"<pre><code>#!/bin/bash\n\nrepositories=(\"granade-io/pluscoder\" \"granade-io/pluscoder-docs\" \"granade-io/pluscoder-cli\")\n\nfor repo in \"${repositories[@]}\"; do\n    echo \"Running PlusCoder for $repo...\"\n    # PlusCoder will clone the repository\n    pluscoder \\\n        --repository $repo \\\n        --source_branch develop \\\n        --user_input \"Add README.md file following guidelines at https://github.com/granade-io/pluscoder/blob/main/docs/README-GUIDELINES.md\" \\\n        --default_agent developer \\\n        --auto_confirm yes \\\n        --auto_commit false\n    cd $repo\n    git add README.md\n    git commit -m \"Add README.md file\"\n    git push origin develop\n    cd ..\ndone\n</code></pre>"},{"location":"documentation/automation/#task-list-for-complex-instructions","title":"Task list for complex instructions","text":"<p>You can define a task list to achieve more complex instructions. Orchestrator agent will handle the task list and delegate tasks to agents until each task is completed.</p> task_list.json <pre><code>{\n\n    \"objective\": \"Update API endpoints documentation\",\n    \"task_list\": [\n    {\n        \"objective\": \"Apply Google Python Style Guide to main app file\",\n        \"details\": \"\"\"\n        - Read Python style guide from https://google.github.io/styleguide/pyguide.html\n        - Apply formatting rules to app/main.py\n        - Fix docstrings format\n        - Adjust import order\n        - Fix naming conventions\n        \"\"\",\n        \"restrictions\": \"Only modify app/main.py file, keep functionality intact\",\n        \"outcome\": \"main.py formatted according to Google Python Style Guide\",\n        \"agent\": \"developer\",\n        \"completed\": false,\n        \"is_finished\": false\n    },\n    {\n        \"objective\": \"Update API endpoints documentation\",\n        \"details\": \"\"\"\n        - Follow OpenAPI 3.0 spec from https://spec.openapis.org/oas/v3.0.3\n        - Update documentation for /users endpoints\n        - Update documentation for /auth endpoints\n        \"\"\",\n        \"restrictions\": \"Only modify api/docs/endpoints.yaml file\",\n        \"outcome\": \"API documentation updated following OpenAPI 3.0 specification\",\n        \"agent\": \"developer\",\n        \"completed\": false,\n        \"is_finished\": false\n    }\n    ]\n}\n</code></pre> <p>PlusCoder will use the orchestration workflow to delegate tasks to agents:</p> <pre><code>pluscoder --task_list task_list.json --auto_confirm yes\n</code></pre> <p>Task list recommendations</p> <p>Task list are executed sequentially and each agent will work on its task until it's completed. We recommend:</p> <ol> <li>Keep tasks simple and focused</li> <li>Define clear objectives and outcomes</li> <li>Use restrictions to avoid unwanted changes</li> <li>Specify involved files and/or guidelines to accomplish the task</li> </ol>"},{"location":"documentation/automation/#python","title":"Python","text":"<p>Warning</p> <p>This feature is still in development.</p>"},{"location":"documentation/automation/#related-docs","title":"Related Docs","text":"<ul> <li>Configuration</li> <li>Agents</li> <li>CLI Usage</li> </ul>"},{"location":"documentation/cli-commands/","title":"Commands","text":"<p>PlusCoder provides several built-in commands to help you manage conversations, repository interactions, and configuration. All commands start with <code>/</code>.</p>"},{"location":"documentation/cli-commands/#general-commands","title":"General Commands","text":"Command\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 Description <code>/help</code> Displays help information for all available commands. <code>/clear</code> Clears the entire chat history with current agent. <code>/config</code> Override any PlusCoder configuration setting.Usage:<code>/config &lt;setting_name&gt; &lt;value&gt;</code>Example:<code>/config auto_commits false</code>"},{"location":"documentation/cli-commands/#agent-management-commands","title":"Agent Management Commands","text":"Command\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 Description <code>/agent</code> Start a new conversation with another agent. Can optionally preserve chat history.Usage:<code>/agent [agent_name]</code>If no agent name is provided, shows interactive selection. <code>/agent_create</code> Creates a new persistent specialized agent to chat with. Interactive process to define:- Code-base interaction capabilities- File editing permissions- Agent specialization and description"},{"location":"documentation/cli-commands/#repository-management-commands","title":"Repository Management Commands","text":"Command\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 Description <code>/diff</code> Shows the diff of the last commit. <code>/undo</code> Reverts last commit and removes messages from history until last user message. <code>/show_repo</code> Displays repository files tree in the current context."},{"location":"documentation/cli-commands/#configuration-system-commands","title":"Configuration &amp; System Commands","text":"Command\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 Description <code>/show_config</code> Displays current PlusCoder configuration and config file locations. <code>/run</code> Executes a system command and displays its output.Usage:<code>/run &lt;command&gt;</code>Example:<code>/run git status</code>"},{"location":"documentation/cli-commands/#custom-prompt-commands","title":"Custom Prompt Commands","text":"Command\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 Description <code>/custom</code> Gives the current agent a pre-defined set of instruction including (optional) additional instructions. Check how to define custom instructions at Custom Prompt Command section. Usage:<code>/custom &lt;prompt_name&gt; [additional instructions]</code>Example:<code>/custom docstrings files display.py and utils.py</code>"},{"location":"documentation/cli/","title":"PlusCoder CLI","text":"<p>PlusCoder provides an enhanced command-line interface for efficient interaction:</p> <p>Warning</p> <p>Some of these features are not available when running inside Docker. Like image pasting using Ctrl + V.</p> Action Description Input History Press the Up Arrow Recall and reuse previous inputs. Multiline Input Press <code>Ctrl + Return</code> or <code>Option + Return</code> Create a new line for multiline commands. Input Clearing Press <code>Ctrl + C</code> Clear the current text in the input field. File Autocomplete Start typing a filename. Use <code>Tab</code> to alternate suggestions. Get suggestions and autocomplete file paths. Paste Support Paste multiline text directly Use standard paste commands in the input field. Quick Confirmation Use <code>y</code> or <code>Y</code> Quickly confirm prompts or actions. Image as context Write <code>img::&lt;url&gt;</code> or <code>img::&lt;local_path&gt;</code> Pass images to agents. Pasting Images Press <code>Ctrl + V</code> Copy images and paste it directly into the terminal to pass the to agents."},{"location":"documentation/cli/#next-steps","title":"Next Steps","text":"<ul> <li>CLI Commands</li> </ul>"},{"location":"documentation/configuration/","title":"Configuration","text":""},{"location":"documentation/configuration/#configuration-methods","title":"Configuration methods","text":"<p>PlusCoder can be configured using several methods (following this precedence order):</p> <ol> <li>The <code>/config</code> in-chat command at runtime</li> <li>Command-line arguments when running <code>pluscoder</code> command.</li> <li>Dotenv variables ( <code>.env</code> file in the repository root)</li> <li><code>.pluscoder-config.yml</code> config file in the repository root</li> <li>Environment variables</li> <li>Global PlusCoder yaml config file (<code>~/.config/pluscoder/config.yml</code> or <code>AppData/Local/pluscoder/config.yml</code>)</li> <li>Global environment variables file (<code>~/.config/pluscoder/vars.env</code> or <code>AppData/Local/pluscoder/vars.env</code>)</li> </ol> <p>Same option can be configured using different methods as mentioned:</p> CLI.env.pluscoder-config.ymlEnv VarsGlobal config.ymlGlobal vars.env <pre><code>pluscoder --model gpt-4o\n# other options...\n</code></pre> <pre><code>MODEL=gpt-4o\n# other options...\n</code></pre> <pre><code>model: gpt-4o\n# other options...\n</code></pre> <pre><code>export MODEL=gpt-4o\npluscoder\n</code></pre> <pre><code>model: gpt-4o\n# other options...\n</code></pre> <pre><code>MODEL=gpt-4o\n# other options...\n</code></pre> <p>Credentials</p> <p>Credentials and keys must be provided as environment variables, using <code>.env</code> or global <code>~/.config/pluscoder/vars.env</code> env file. Passing credentials in other files won't work.</p> <p>To display current configuration settings, run in-chat command <code>/show_config</code> or pass config flag <code>show_config</code>.</p> <pre><code>pluscoder --show_config\n</code></pre> <p>Global configuration files location</p> <p><code>--show_config</code> will also display configuration files location specific to your operating system.</p>"},{"location":"documentation/configuration/#configuration-options","title":"Configuration options","text":""},{"location":"documentation/configuration/#application-behavior","title":"Application Behavior","text":"<ul> <li><code>read_only</code>: Enable/disable read-only mode to avoid file editions (default: <code>False</code>)</li> <li><code>streaming</code>: Enable/disable LLM streaming (default: <code>True</code>)</li> <li><code>auto_confirm</code>: Enable/disable auto confirmation of pluscoder execution (default: <code>False</code>)</li> <li><code>hide_thinking_blocks</code>: Hide thinking blocks in LLM output (default: <code>True</code>)</li> <li><code>hide_output_blocks</code>: Hide output blocks in LLM output (default: <code>False</code>)</li> <li><code>hide_source_blocks</code>: Hide source blocks in LLM output (default: <code>False</code>)</li> <li><code>show_token_usage</code>: Show token usage/cost (default: <code>True</code>)</li> <li><code>default_agent</code>: Specify the name/number of the default agent to use. If not specified selection will be interactive (default: <code>None</code>)</li> </ul>"},{"location":"documentation/configuration/#file-paths","title":"File Paths","text":"<ul> <li><code>log_filename</code>: Filename for logs (default: <code>\"pluscoder.log\"</code>)</li> </ul>"},{"location":"documentation/configuration/#models-and-providers","title":"Models and Providers","text":"<p>Models:</p> <ul> <li><code>model</code>: LLM model to use. Required. (default: <code>None</code>)</li> <li><code>orchestrator_model</code>: LLM model to use for orchestrator (default: same as <code>MODEL</code>)</li> <li><code>embedding_model</code>: Embedding model to use for building vector database of the repository (default: <code>None</code>).</li> </ul> <p>Indexing with Embedding Model</p> <p>To improve LLMs performance, we strongly recommend using an embedding model. This will allow PlusCoder to index the repository and provide better context to the AI. Check some examples at Indexing.</p> <p>Provider:</p> <ul> <li><code>provider</code>: LLM provider to use. If <code>None</code>, provider will be selected based on available environment variables credentials. Options: <code>aws_bedrock</code>, <code>openai</code>, <code>litellm</code>, <code>anthropic</code>, <code>vertexai</code>, <code>google</code> (default: <code>None</code>)</li> <li><code>orchestrator_model_provider</code>: Provider to use for orchestrator agent (default: same as <code>PROVIDER</code>)</li> </ul>"},{"location":"documentation/configuration/#provider-credentials","title":"Provider Credentials","text":"<p>Define these at <code>.env</code>, <code>~/.config/pluscoder/vars.env</code> or using <code>export VAR=value</code>:</p> <p>OpenAI:</p> <ul> <li><code>OPENAI_API_KEY</code>: OpenAI API key. (default: <code>None</code>)</li> <li><code>OPENAI_API_BASE</code>: OpenAI API base URL. (default: <code>None</code>)</li> </ul> <p>Anthropic:</p> <ul> <li><code>ANTHROPIC_API_KEY</code>: Anthropic API key. (default: <code>None</code>)</li> </ul> <p>AWS</p> <ul> <li><code>AWS_ACCESS_KEY_ID</code>: AWS Access Key ID. (default: <code>None</code>)</li> <li><code>AWS_SECRET_ACCESS_KEY</code>: AWS Secret Access Key. (default: <code>None</code>)</li> <li><code>AWS_PROFILE</code>: AWS profile name (default: <code>\"default\"</code>)</li> </ul>"},{"location":"documentation/configuration/#repository-settings","title":"Repository Settings","text":"<p>Use these when running PlusCoder in remote repositories for automated runs. Check how at Automated Runs.</p> <ul> <li><code>repository</code>: Git repository path or URL to clone and process (default: <code>None</code>)</li> <li><code>source_branch</code>: Specify source branch to checkout when cloning repository (default: <code>None</code>)</li> <li><code>repo_exclude_files</code>: List of regex patterns to exclude files from repo operations (default: <code>[]</code>)</li> <li><code>repo_include_only_files</code>: List of regex patterns to include only specific files from repo operations (default: <code>[]</code>)</li> </ul> .pluscoder-config.yml <pre><code># exclude files based on their extensions from agents context\nrepo_exclude_files: [\".(png|jpg|jpeg|svg)\"]\n# include only Python and Markdown files\nrepo_include_only_files: [\".py\"]\n</code></pre> <p>Known issue</p> <p>Do not use \\ (backslash) symbol in the regex patterns to scape characters, yaml won't parse. Use <code>.</code> instead.</p>"},{"location":"documentation/configuration/#git-settings","title":"Git Settings","text":"<ul> <li><code>auto_commits</code>: Enable/disable automatic Git commits after successful agent file editions (default: <code>False</code>)</li> <li><code>allow_dirty_commits</code>: Allow commits in a dirty repository (default: <code>False</code>)</li> </ul>"},{"location":"documentation/configuration/#test-and-lint-settings","title":"Test and Lint Settings","text":"<p>Tests and Lint commands are executed after any file edition. Agents will try to fix any error found by these commands.</p> <ul> <li><code>run_tests_after_edit</code>: Run tests after file edits (default: <code>False</code>)</li> <li><code>run_lint_after_edit</code>: Run linter after file edits (default: <code>False</code>)</li> <li><code>test_command</code>: Command to run tests (default: <code>None</code>)</li> <li><code>lint_command</code>: Command to run linter (default: <code>None</code>)</li> <li><code>auto_run_linter_fix</code>: Automatically run linter fix before linting (default: <code>False</code>)</li> <li><code>lint_fix_command</code>: Command to run linter fix (default: <code>None</code>)</li> </ul> .pluscoder-config.yml <pre><code>run_tests_after_edit: true\nrun_lint_after_edit: true\nauto_run_linter_fix: true\ntest_command: make test\nlint_command: make lint\nlint_fix_command: make lint-fix\n</code></pre>"},{"location":"documentation/configuration/#custom-prompt-commands","title":"Custom Prompt Commands","text":"<p>Custom prompt commands allow you to define pre-configured prompts/instruction that can be easily executed during runtime and passed to agents.</p> <ul> <li><code>custom_prompt_commands</code>: List of custom prompts (default: <code>[]</code>). Each containing:<ul> <li><code>prompt_name</code>: A unique name for the command</li> <li><code>description</code>: A brief description of what the command does</li> <li><code>prompt</code>: The prompt suffix text to be sent to the agent along a custom message</li> </ul> </li> </ul> .pluscoder-config.yml <pre><code>custom_prompt_commands:\n  - prompt_name: docstring\n    prompt: |\n      Please add docstring to these files above\n    description: \"Generate docstring for specified files\"\n  - prompt_name: brainstorm\n    description: Propose ideas for implementation without editing code base.\n    prompt: |\n      Based on the previous request, please perform a brainstorm of how could this achieved. \n        1. Read key files, analyze them\n        2. Tell me with a bullet point list, the role of each involved file\n        3. Tell me a proposed plan in natural language\n      Follow instructions above without editing files\n</code></pre> <p>During the chat in the interactive mode, you can use these custom instructions as follows:</p> In-chat <pre><code>/custom docstring\n/custom brainstorm i want a new api endpoints to register users and authenticate them\n</code></pre>"},{"location":"documentation/configuration/#custom-agents","title":"Custom Agents","text":"<p>PlusCoder supports the creation of custom agents with different specializations. These agents can be defined in the configuration and used alongside the predefined agents.</p> <ul> <li><code>custom_agents</code> List of custom agent configurations (default: <code>[]</code>). Each containing:<ul> <li><code>name</code>: A unique name for the agent</li> <li><code>description</code>: a description of the agent</li> <li><code>prompt</code>: The system prompt defining the agent's role and capabilities</li> <li><code>repository_interaction</code>: Where or not the agent can interact with the repository. Useful for agents repository agnostic.</li> <li><code>read_only</code>: Boolean indicating whether the agent is restricted to read-only file operations</li> <li><code>reminder</code>: Reminder to the agent to send with every user message</li> <li><code>default_context_files</code>: Files that the agent will read automatically every chat session or execution</li> <li><code>tools</code>: Names of the tools available for the agent. By default (if not defined) all pre-defined tools are available.</li> </ul> </li> </ul> .pluscoder-config.yml <pre><code>custom_agents:\n  - name: CodeReviewer\n    description: Agent description\n    prompt: \"You are a code reviewer. Your task is to review code changes and provide feedback on code quality, best practices, and potential issues.\"\n    read_only: true\n  - name: DocumentationWriter\n    description: Agent description\n    prompt: \"You are a technical writer specializing in software documentation. Your task is to create and update project documentation, including README files, API documentation, and user guides.\"\n    read_only: false\n</code></pre> <p>Custom agents can be selected at the start of the chat in the interactive mode, by using <code>default_agent</code> option or by using the <code>/agent</code> command followed by the agent name.</p> CLIIn-chat <pre><code># choose agent by name\npluscoder --default_agent codereviewer\n# or by number in the given list\npluscoder --default_agent 4\n</code></pre> <pre><code>/agent CodeReviewer\n</code></pre> <p>You can also create a custom agent using the <code>/agent_create</code> command.</p>"},{"location":"documentation/configuration/#related-docs","title":"Related Docs","text":"<ul> <li>Agents</li> <li>CLI Usage</li> </ul>"},{"location":"documentation/tools/","title":"Tools","text":"<p>To properly work with a repository, PlusCoder agents have access to a set of tools that help them to perform tasks and instructions. These tools are used to interact with the repository, and more.</p>"},{"location":"documentation/tools/#pre-defined-tools","title":"Pre-defined tools","text":"<p>By default all agents have access to the following tools:</p> Tool Description read_files Allows agents to read multiple repository files at once, getting their contents to analyze code and documentation move_files Enables agents to move multiple files between different locations in the repository structure read_file_from_url Provides agents capability to read files from external URLs and repository links query_repository Lets agents search through repository files and code snippets using natural language queries to find relevant information <p>Most of the time there is no need to disable these tools, but if you want to do so, you can configure agents to disable some of them:</p> Python <pre><code>from pluscoder.tools import base_tools\nfrom pluscoder.type import AgentConfig\nfrom pluscoder.agents.core import DeveloperAgent\n\n# Override agent default tools\ndisabled_tool_names = ['read_files', 'move_files', 'query_repository']\ntool_names = [tool.name for tool in tools.base_tools if tool.name not in disabled_tool_names]\ndeveloper_agent: AgentConfig = DeveloperAgent.to_agent_config(tools=tool_names)\n</code></pre> <p>Specifying tools for custom agents</p> <p>Custom Agents can also be configured to use a specific set of tools. By default all pre-defined tools are available.</p>"},{"location":"documentation/tools/#custom-tools","title":"Custom tools","text":"<p>In addition to the pre-defined tools, you can create custom tools to extend the capabilities of the agents. Custom tools can be created through Python.</p> <p>Custom tools are not available in the interactive mode</p> <p>Custom tools are not available in the interactive mode, but they can be used in the Python API.</p> <p>Here an example to read open issues and read issue details:</p> Python <pre><code>from langchain_core.tools import tool\nfrom pluscoder.tools import base_tools\nfrom pluscoder.type import AgentConfig\nfrom pluscoder.agents.core import DeveloperAgent\nfrom pluscoder.workflow import run_agent\n\n@tool\ndef read_open_repository_issues() -&gt; str:\n    \"Read most recent open issues from the repository\"\n    ...\n    &lt;logic&gt;\n    ...\n    return f\"Issues: {issues_text}\"\n\n@tool\ndef read_issue_details(issue_id: Annotated[int, \"Id of the issue to read\"] ) -&gt; str:\n    \"Read details of an issue by its id\"\n    ...\n    &lt;logic&gt;\n    ...\n    return f\"Issue Details: {issue_details}\"\n\ndef comment_issue(issue_id: Annotated[int, \"Id of the issue to comment\"], markdown_comment: Annotated[str, \"Markdown comment to add to the issue\"]) -&gt; str:\n    \"Add markdown comments to an specific issue by its id\"\n    ...\n    &lt;logic&gt;\n    ...\n    return f\"Issue with ID {issue_id} has been successfully commented\"\n\n\n# Override agent default tools\nmy_tools = tools.base_tools + [read_open_repository_issues, read_issue_details, comment_issue]\ndeveloper_agent: AgentConfig = DeveloperAgent.to_agent_config(tools=my_tools)\n\n# Run the agent\nrun_agent(\n    agent=developer_agent, \n    input=\"\"\"Read details about any tech debt issue,\nbrainstorm about how to solve it and code the proposed solution\"\"\",\n), \n</code></pre>"},{"location":"documentation/tools/#related-docs","title":"Related Docs","text":"<ul> <li>Configuration</li> <li>Agents</li> </ul>"},{"location":"examples/","title":"Examples","text":"<p>This is a collection of examples that demonstrate how to use PlusCoder through CLI or Python.</p> <ol> <li>Basic coding instruction: A simple example of using PlusCoder to instruct agent to generate a README file from a repository.</li> <li>Issues Management: An example of using PlusCoder to read an issue in a repository and code a proposed solution.</li> <li>Code Review: Use PlusCoder to review a code and suggest improvements given some guidelines.</li> <li>Custom Agents: Demonstrate how to create a custom agent using PlusCoder.</li> <li>Remote Configuration: Show how to remotely configure PlusCoder for reusing agents across different users.</li> </ol>"},{"location":"local/","title":"Local Development Guide","text":""},{"location":"local/#overview","title":"Overview","text":"<p>Explore how to use PlusCoder in local development environments, including CLI usage, configuration, and custom agent creation.</p>"},{"location":"local/#sections","title":"Sections","text":"<ul> <li>Command Line Interface (CLI)</li> <li>Local Configuration</li> <li>Interacting with PlusCoder</li> <li>Creating Custom Agents</li> <li>Tips and Tricks</li> </ul>"},{"location":"local/agents/","title":"Agents","text":""},{"location":"local/cli/","title":"Command Line Interface (CLI)","text":""},{"location":"local/configuration/","title":"Local Configuration","text":""},{"location":"local/talk_to_pluscoder/","title":"Interacting with PlusCoder","text":""},{"location":"local/tips_and_tricks/","title":"Tips and Tricks","text":""},{"location":"local/tools/","title":"Tools","text":""}]}